{
	"appsUsed":[
		
	],
	"createdTime":1761668994563,
	"deleted":false,
	"deploymentState":{
		"deployedAt":1761671858632,
		"deployedBy":186875,
		"deployedDefinitionId":"6900fab2121d195dbbfaa285",
		"status":"DEPLOYED",
		"version":3,
		"workflowVersion":4
	},
	"edges":[
		{
			"fromNodeId":"n_uCnw9",
			"priority":0,
			"skip":false,
			"toNodeId":"n_1KJCW",
			"type":"next"
		},
		{
			"fromNodeId":"n_1KJCW",
			"priority":0,
			"skip":false,
			"toNodeId":"_my5ex",
			"type":"next"
		},
		{
			"fromNodeId":"_my5ex",
			"priority":0,
			"skip":false,
			"toNodeId":"_QZ5pN",
			"type":"next"
		},
		{
			"fromNodeId":"_QZ5pN",
			"priority":0,
			"skip":false,
			"toNodeId":"_PlTO6",
			"type":"next"
		},
		{
			"fromNodeId":"_PlTO6",
			"priority":0,
			"skip":false,
			"toNodeId":"_UJ47G",
			"type":"next"
		},
		{
			"fromNodeId":"_UJ47G",
			"priority":0,
			"skip":false,
			"toNodeId":"_o3KbW",
			"type":"next"
		},
		{
			"fromNodeId":"_o3KbW",
			"priority":0,
			"skip":false,
			"toNodeId":"_HlLmw",
			"type":"next"
		},
		{
			"fromNodeId":"_HlLmw",
			"priority":0,
			"skip":false,
			"toNodeId":"_CzrNP",
			"type":"next"
		},
		{
			"fromNodeId":"_CzrNP",
			"priority":0,
			"skip":false,
			"toNodeId":"_SC8Vw",
			"type":"next"
		},
		{
			"fromNodeId":"_SC8Vw",
			"priority":0,
			"skip":false,
			"toNodeId":"_qz4Ox",
			"type":"next"
		},
		{
			"fromNodeId":"_qz4Ox",
			"priority":0,
			"skip":false,
			"toNodeId":"_P59Eh",
			"type":"next"
		}
	],
	"id":"6900ef82a0bcbf740ac5b382",
	"lastModifiedBy":186875,
	"lcName":"testauto2811",
	"modifiedTime":1761672042950,
	"name":"testauto2811",
	"nodes":[
		{
			"context":{
				"appName":"webhooks",
				"resourceVersion":833,
				"resourceName":"webhooks_default"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"n_uCnw9",
			"index":1,
			"inputs":{
				"request":{
					"contentType":"application/json"
				}
			},
			"skip":false,
			"subTitle":"Webhook",
			"title":"New event",
			"trigger":{
				"type":"WEBHOOK"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"n_1KJCW",
			"index":2,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_my5ex",
			"index":3,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_QZ5pN",
			"index":4,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_PlTO6",
			"index":5,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_UJ47G",
			"index":6,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_o3KbW",
			"index":7,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_HlLmw",
			"index":8,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_CzrNP",
			"index":9,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_SC8Vw",
			"index":10,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_qz4Ox",
			"index":11,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_P59Eh",
			"index":12,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		}
	],
	"ownerUserId":186875,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":false,
	"tags":[
		
	],
	"version":5
}