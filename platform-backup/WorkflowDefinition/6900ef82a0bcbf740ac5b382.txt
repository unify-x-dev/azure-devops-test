{
	"appsUsed":[
		
	],
	"createdTime":1761668994563,
	"deleted":false,
	"deploymentState":{
		"deployedAt":1761672190176,
		"deployedBy":186875,
		"deployedDefinitionId":"6900fbfd121d195dbbfaa475",
		"status":"DEPLOYED",
		"version":4,
		"workflowVersion":5
	},
	"edges":[
		{
			"fromNodeId":"n_uCnw9",
			"priority":0,
			"skip":false,
			"toNodeId":"n_1KJCW",
			"type":"next"
		},
		{
			"fromNodeId":"n_1KJCW",
			"priority":0,
			"skip":false,
			"toNodeId":"_my5ex",
			"type":"next"
		},
		{
			"fromNodeId":"_my5ex",
			"priority":0,
			"skip":false,
			"toNodeId":"_QZ5pN",
			"type":"next"
		},
		{
			"fromNodeId":"_QZ5pN",
			"priority":0,
			"skip":false,
			"toNodeId":"_PlTO6",
			"type":"next"
		},
		{
			"fromNodeId":"_PlTO6",
			"priority":0,
			"skip":false,
			"toNodeId":"_UJ47G",
			"type":"next"
		},
		{
			"fromNodeId":"_UJ47G",
			"priority":0,
			"skip":false,
			"toNodeId":"_o3KbW",
			"type":"next"
		},
		{
			"fromNodeId":"_o3KbW",
			"priority":0,
			"skip":false,
			"toNodeId":"_HlLmw",
			"type":"next"
		},
		{
			"fromNodeId":"_HlLmw",
			"priority":0,
			"skip":false,
			"toNodeId":"_CzrNP",
			"type":"next"
		},
		{
			"fromNodeId":"_CzrNP",
			"priority":0,
			"skip":false,
			"toNodeId":"_SC8Vw",
			"type":"next"
		},
		{
			"fromNodeId":"_SC8Vw",
			"priority":0,
			"skip":false,
			"toNodeId":"_qz4Ox",
			"type":"next"
		},
		{
			"fromNodeId":"_qz4Ox",
			"priority":0,
			"skip":false,
			"toNodeId":"_R2wws",
			"type":"next"
		},
		{
			"fromNodeId":"_R2wws",
			"priority":0,
			"skip":false,
			"toNodeId":"_7rKyo",
			"type":"next"
		},
		{
			"fromNodeId":"_7rKyo",
			"priority":0,
			"skip":false,
			"toNodeId":"_P59Eh",
			"type":"next"
		}
	],
	"id":"6900ef82a0bcbf740ac5b382",
	"lastModifiedBy":186875,
	"lcName":"testauto2811",
	"modifiedTime":1761673019031,
	"name":"testauto2811",
	"nodes":[
		{
			"context":{
				"appName":"webhooks",
				"resourceVersion":833,
				"resourceName":"webhooks_default"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"n_uCnw9",
			"index":1,
			"inputs":{
				"request":{
					"contentType":"application/json"
				}
			},
			"skip":false,
			"subTitle":"Webhook",
			"title":"New event",
			"trigger":{
				"type":"WEBHOOK"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"n_1KJCW",
			"index":2,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_my5ex",
			"index":3,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_QZ5pN",
			"index":4,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_PlTO6",
			"index":5,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_UJ47G",
			"index":6,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_o3KbW",
			"index":7,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_HlLmw",
			"index":8,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_CzrNP",
			"index":9,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_SC8Vw",
			"index":10,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_qz4Ox",
			"index":11,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_R2wws",
			"index":12,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_7rKyo",
			"index":13,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\nimport java.time.temporal.ChronoUnit\n\ndef executeComprehensiveEnterpriseDataPipeline() {\n    def masterResults = [:]\n    def pipelineStart = System.currentTimeMillis()\n    \n    def employeeData = [\n        [id: 1, name: 'Alice Johnson', dept: 'Engineering', sal: 95000, hire: '2018-03-15', perf: 4.5, skills: ['Java', 'Python', 'SQL'], loc: 'NYC', education: 'Masters', certifications: 3],\n        [id: 2, name: 'Bob Smith', dept: 'Engineering', sal: 110000, hire: '2016-07-22', perf: 4.8, skills: ['Java', 'AWS', 'Kubernetes'], loc: 'SF', education: 'Bachelors', certifications: 5],\n        [id: 3, name: 'Carol Davis', dept: 'Sales', sal: 75000, hire: '2019-01-10', perf: 4.2, skills: ['CRM', 'Negotiation'], loc: 'NYC', education: 'Bachelors', certifications: 2],\n        [id: 4, name: 'Dave Wilson', dept: 'Marketing', sal: 68000, hire: '2020-05-18', perf: 3.9, skills: ['SEO', 'Analytics'], loc: 'LA', education: 'Bachelors', certifications: 1],\n        [id: 5, name: 'Eve Martinez', dept: 'Engineering', sal: 88000, hire: '2019-11-03', perf: 4.3, skills: ['Docker', 'Python', 'CI/CD'], loc: 'NYC', education: 'Masters', certifications: 4],\n        [id: 6, name: 'Frank Brown', dept: 'HR', sal: 72000, hire: '2017-09-12', perf: 4.0, skills: ['Recruitment', 'HRIS'], loc: 'SF', education: 'Bachelors', certifications: 2],\n        [id: 7, name: 'Grace Lee', dept: 'Finance', sal: 82000, hire: '2018-02-28', perf: 4.6, skills: ['Excel', 'SAP'], loc: 'NYC', education: 'Masters', certifications: 3],\n        [id: 8, name: 'Hank Chen', dept: 'Engineering', sal: 102000, hire: '2017-06-14', perf: 4.7, skills: ['Scala', 'Spark'], loc: 'SF', education: 'PhD', certifications: 6],\n        [id: 9, name: 'Ivy Rodriguez', dept: 'Sales', sal: 78000, hire: '2020-08-20', perf: 4.1, skills: ['B2B', 'Strategy'], loc: 'LA', education: 'Bachelors', certifications: 2],\n        [id: 10, name: 'Jack Taylor', dept: 'Marketing', sal: 71000, hire: '2019-12-05', perf: 3.8, skills: ['Content'], loc: 'NYC', education: 'Bachelors', certifications: 1],\n        [id: 11, name: 'Karen White', dept: 'Engineering', sal: 98000, hire: '2018-11-20', perf: 4.4, skills: ['Go', 'Microservices'], loc: 'SF', education: 'Masters', certifications: 4],\n        [id: 12, name: 'Leo Harris', dept: 'Sales', sal: 80000, hire: '2017-03-08', perf: 4.5, skills: ['Enterprise', 'Contracts'], loc: 'NYC', education: 'Masters', certifications: 3],\n        [id: 13, name: 'Mia Clark', dept: 'HR', sal: 69000, hire: '2021-01-15', perf: 3.7, skills: ['Training', 'Benefits'], loc: 'LA', education: 'Bachelors', certifications: 1],\n        [id: 14, name: 'Nick Lewis', dept: 'Finance', sal: 91000, hire: '2016-08-30', perf: 4.6, skills: ['Accounting', 'Tax'], loc: 'SF', education: 'Masters', certifications: 4],\n        [id: 15, name: 'Olivia Walker', dept: 'Marketing', sal: 73000, hire: '2019-04-12', perf: 4.0, skills: ['Digital', 'Social'], loc: 'NYC', education: 'Bachelors', certifications: 2],\n        [id: 16, name: 'Paul Garcia', dept: 'Engineering', sal: 105000, hire: '2015-06-10', perf: 4.9, skills: ['Python', 'ML', 'AI'], loc: 'SF', education: 'PhD', certifications: 7],\n        [id: 17, name: 'Quinn Martinez', dept: 'Sales', sal: 77000, hire: '2020-02-14', perf: 4.0, skills: ['Sales', 'CRM'], loc: 'LA', education: 'Bachelors', certifications: 2],\n        [id: 18, name: 'Rachel Thompson', dept: 'Marketing', sal: 70000, hire: '2021-03-20', perf: 3.6, skills: ['Content', 'SEO'], loc: 'NYC', education: 'Bachelors', certifications: 1],\n        [id: 19, name: 'Sam Anderson', dept: 'Finance', sal: 85000, hire: '2018-07-15', perf: 4.4, skills: ['Excel', 'Finance'], loc: 'SF', education: 'Masters', certifications: 3],\n        [id: 20, name: 'Tina Moore', dept: 'HR', sal: 74000, hire: '2019-09-01', perf: 4.1, skills: ['HR', 'Compliance'], loc: 'NYC', education: 'Masters', certifications: 3],\n        [id: 21, name: 'Uma Patel', dept: 'Engineering', sal: 92000, hire: '2019-05-12', perf: 4.3, skills: ['Java', 'Spring'], loc: 'LA', education: 'Bachelors', certifications: 3],\n        [id: 22, name: 'Victor Kim', dept: 'Sales', sal: 81000, hire: '2018-11-25', perf: 4.4, skills: ['B2B', 'Sales'], loc: 'SF', education: 'Bachelors', certifications: 2],\n        [id: 23, name: 'Wendy Zhang', dept: 'Marketing', sal: 72000, hire: '2020-01-08', perf: 3.9, skills: ['Marketing', 'Analytics'], loc: 'NYC', education: 'Masters', certifications: 2],\n        [id: 24, name: 'Xavier Lopez', dept: 'Finance', sal: 88000, hire: '2017-04-18', perf: 4.5, skills: ['Accounting', 'Audit'], loc: 'LA', education: 'Masters', certifications: 4],\n        [id: 25, name: 'Yuki Tanaka', dept: 'Engineering', sal: 96000, hire: '2018-08-22', perf: 4.6, skills: ['Python', 'DevOps'], loc: 'SF', education: 'Masters', certifications: 5],\n        [id: 26, name: 'Zara Ahmed', dept: 'HR', sal: 71000, hire: '2020-06-30', perf: 3.8, skills: ['Recruitment', 'HR'], loc: 'NYC', education: 'Bachelors', certifications: 1],\n        [id: 27, name: 'Alan Cooper', dept: 'Engineering', sal: 99000, hire: '2017-12-05', perf: 4.5, skills: ['JavaScript', 'React'], loc: 'LA', education: 'Bachelors', certifications: 4],\n        [id: 28, name: 'Beth Collins', dept: 'Sales', sal: 76000, hire: '2019-08-14', perf: 4.2, skills: ['Sales', 'Strategy'], loc: 'SF', education: 'Bachelors', certifications: 2],\n        [id: 29, name: 'Chris Murphy', dept: 'Marketing', sal: 69000, hire: '2021-02-20', perf: 3.7, skills: ['Digital', 'Content'], loc: 'NYC', education: 'Bachelors', certifications: 1],\n        [id: 30, name: 'Diana Foster', dept: 'Finance', sal: 84000, hire: '2018-10-11', perf: 4.3, skills: ['Finance', 'Tax'], loc: 'LA', education: 'Masters', certifications: 3]\n    ]\n    \n    def projectData = [\n        [id: 'P001', name: 'Cloud Migration', budget: 500000, team: [1, 2, 5, 11, 16], status: 'Active', priority: 'High', startDate: '2024-01-15', endDate: '2024-12-31'],\n        [id: 'P002', name: 'CRM Upgrade', budget: 300000, team: [3, 9, 12, 17, 22], status: 'Active', priority: 'Medium', startDate: '2024-03-01', endDate: '2024-09-30'],\n        [id: 'P003', name: 'Marketing Campaign', budget: 150000, team: [4, 10, 15, 18, 23], status: 'Planning', priority: 'Low', startDate: '2024-06-01', endDate: '2024-11-30'],\n        [id: 'P004', name: 'HR System', budget: 200000, team: [6, 13, 20, 26], status: 'Active', priority: 'Medium', startDate: '2024-02-15', endDate: '2024-08-31'],\n        [id: 'P005', name: 'Financial Audit', budget: 250000, team: [7, 14, 19, 24], status: 'Completed', priority: 'High', startDate: '2023-09-01', endDate: '2024-02-28'],\n        [id: 'P006', name: 'Mobile App Development', budget: 400000, team: [1, 5, 21, 25, 27], status: 'Active', priority: 'High', startDate: '2024-04-01', endDate: '2025-03-31'],\n        [id: 'P007', name: 'Data Analytics Platform', budget: 350000, team: [2, 8, 16, 25], status: 'Planning', priority: 'Medium', startDate: '2024-07-01', endDate: '2025-06-30'],\n        [id: 'P008', name: 'Sales Automation', budget: 180000, team: [3, 12, 17, 22, 28], status: 'Active', priority: 'Medium', startDate: '2024-05-01', endDate: '2024-10-31'],\n        [id: 'P009', name: 'Compliance Training', budget: 100000, team: [6, 13, 20, 26], status: 'Completed', priority: 'Low', startDate: '2023-11-01', endDate: '2024-01-31'],\n        [id: 'P010', name: 'Security Enhancement', budget: 300000, team: [2, 11, 16, 21], status: 'Active', priority: 'High', startDate: '2024-03-15', endDate: '2024-09-15']\n    ]\n    \n    def trainingPrograms = [\n        [id: 'T001', name: 'Leadership Development', duration: 40, cost: 5000, capacity: 20],\n        [id: 'T002', name: 'Technical Skills Advanced', duration: 80, cost: 8000, capacity: 15],\n        [id: 'T003', name: 'Sales Excellence', duration: 30, cost: 3000, capacity: 25],\n        [id: 'T004', name: 'Financial Analysis', duration: 50, cost: 6000, capacity: 20],\n        [id: 'T005', name: 'Digital Marketing', duration: 35, cost: 4000, capacity: 20],\n        [id: 'T006', name: 'HR Best Practices', duration: 25, cost: 3500, capacity: 15],\n        [id: 'T007', name: 'Cloud Architecture', duration: 60, cost: 7000, capacity: 10],\n        [id: 'T008', name: 'Agile Methodology', duration: 20, cost: 2500, capacity: 30],\n        [id: 'T009', name: 'Data Science', duration: 100, cost: 10000, capacity: 12],\n        [id: 'T010', name: 'Cybersecurity Basics', duration: 30, cost: 4500, capacity: 25]\n    ]\n    \n    def formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\n    def today = LocalDate.now()\n    \n    def enrichedEmployees = employeeData.collect { emp ->\n        def hireDate = LocalDate.parse(emp.hire, formatter)\n        def daysSinceHire = ChronoUnit.DAYS.between(hireDate, today)\n        def yearsOfService = Period.between(hireDate, today).years\n        def monthsOfService = Period.between(hireDate, today).months\n        def weeksSinceHire = daysSinceHire / 7\n        \n        def baseBonus = emp.sal * 0.10\n        def performanceBonus = emp.sal * (emp.perf / 5.0) * 0.05\n        def tenureBonus = yearsOfService * 500\n        def certificationBonus = emp.certifications * 1000\n        def educationBonus = emp.education == 'PhD' ? 5000 : (emp.education == 'Masters' ? 3000 : 1000)\n        def totalBonus = baseBonus + performanceBonus + tenureBonus + certificationBonus + educationBonus\n        \n        def adjustedSalary = emp.sal * (1 + (yearsOfService * 0.02))\n        def projectedSalary1Year = emp.sal * 1.03\n        def projectedSalary3Year = emp.sal * Math.pow(1.03, 3)\n        def projectedSalary5Year = emp.sal * Math.pow(1.03, 5)\n        \n        def retirementContribution = emp.sal * 0.06\n        def healthBenefits = 12000\n        def stockOptions = emp.sal * 0.08\n        def lifetimeEarnings = emp.sal * yearsOfService\n        def totalCompensation = emp.sal + totalBonus + retirementContribution + healthBenefits + stockOptions\n        \n        def skillValue = emp.skills.size() * 5000\n        def performanceMultiplier = emp.perf / 4.0\n        def marketValue = emp.sal * performanceMultiplier * 1.15\n        def replacementCost = emp.sal * 1.5\n        def trainingInvestment = yearsOfService * 10000\n        \n        def productivityScore = (emp.perf * emp.skills.size() * yearsOfService) / 10\n        def valueToCompany = productivityScore * 10000\n        def roi = valueToCompany / (emp.sal + trainingInvestment)\n        \n        def promotionEligibility = yearsOfService >= 2 && emp.perf >= 4.0 && emp.certifications >= 2\n        def bonusEligibility = emp.perf >= 3.5\n        def riseEligibility = emp.perf >= 4.5 && yearsOfService >= 3\n        \n        [\n            id: emp.id,\n            name: emp.name,\n            department: emp.dept,\n            location: emp.loc,\n            education: emp.education,\n            certifications: emp.certifications,\n            baseSalary: emp.sal,\n            adjustedSalary: adjustedSalary,\n            projectedSalary1Year: projectedSalary1Year,\n            projectedSalary3Year: projectedSalary3Year,\n            projectedSalary5Year: projectedSalary5Year,\n            hireDate: hireDate,\n            daysSinceHire: daysSinceHire,\n            weeksSinceHire: weeksSinceHire,\n            yearsOfService: yearsOfService,\n            monthsOfService: monthsOfService,\n            skills: emp.skills,\n            skillCount: emp.skills.size(),\n            skillValue: skillValue,\n            performance: emp.perf,\n            performanceMultiplier: performanceMultiplier,\n            marketValue: marketValue,\n            replacementCost: replacementCost,\n            baseBonus: baseBonus,\n            performanceBonus: performanceBonus,\n            tenureBonus: tenureBonus,\n            certificationBonus: certificationBonus,\n            educationBonus: educationBonus,\n            totalBonus: totalBonus,\n            retirementContribution: retirementContribution,\n            healthBenefits: healthBenefits,\n            stockOptions: stockOptions,\n            totalCompensation: totalCompensation,\n            lifetimeEarnings: lifetimeEarnings,\n            trainingInvestment: trainingInvestment,\n            productivityScore: productivityScore,\n            valueToCompany: valueToCompany,\n            roi: roi,\n            promotionEligibility: promotionEligibility,\n            bonusEligibility: bonusEligibility,\n            riseEligibility: riseEligibility\n        ]\n    }\n    \n    def departmentGroups = enrichedEmployees.groupBy { it.department }\n    def locationGroups = enrichedEmployees.groupBy { it.location }\n    def educationGroups = enrichedEmployees.groupBy { it.education }\n    \n    def performanceTiers = enrichedEmployees.groupBy { emp ->\n        if (emp.performance >= 4.5) return 'Excellent'\n        else if (emp.performance >= 4.0) return 'Good'\n        else if (emp.performance >= 3.5) return 'Average'\n        else return 'NeedsImprovement'\n    }\n    \n    def tenureTiers = enrichedEmployees.groupBy { emp ->\n        if (emp.yearsOfService >= 7) return 'Senior'\n        else if (emp.yearsOfService >= 3) return 'Mid'\n        else return 'Junior'\n    }\n    \n    def salaryTiers = enrichedEmployees.groupBy { emp ->\n        if (emp.baseSalary >= 100000) return 'High'\n        else if (emp.baseSalary >= 80000) return 'Medium'\n        else return 'Entry'\n    }\n    \n    def departmentAnalytics = [:]\n    departmentGroups.each { dept, employees ->\n        def salaries = employees*.baseSalary\n        def compensations = employees*.totalCompensation\n        def performances = employees*.performance\n        def tenures = employees*.yearsOfService\n        def certifications = employees*.certifications\n        def productivityScores = employees*.productivityScore\n        def marketValues = employees*.marketValue\n        def replacementCosts = employees*.replacementCost\n        \n        def avgSalary = salaries.sum() / salaries.size()\n        def minSalary = salaries.min()\n        def maxSalary = salaries.max()\n        def salaryRange = maxSalary - minSalary\n        def medianSalary = salaries.sort()[salaries.size().intdiv(2)]\n        def totalPayroll = salaries.sum()\n        \n        def avgCompensation = compensations.sum() / compensations.size()\n        def totalCompensation = compensations.sum()\n        def minCompensation = compensations.min()\n        def maxCompensation = compensations.max()\n        \n        def totalBonuses = employees*.totalBonus.sum()\n        def avgBonus = totalBonuses / employees.size()\n        def totalRetirement = employees*.retirementContribution.sum()\n        def totalStockOptions = employees*.stockOptions.sum()\n        def totalBenefits = employees*.healthBenefits.sum()\n        \n        def avgPerformance = performances.sum() / performances.size()\n        def maxPerformance = performances.max()\n        def minPerformance = performances.min()\n        def performanceRange = maxPerformance - minPerformance\n        \n        def avgTenure = tenures.sum() / tenures.size()\n        def maxTenure = tenures.max()\n        def minTenure = tenures.min()\n        def tenureRange = maxTenure - minTenure\n        \n        def avgCertifications = certifications.sum() / certifications.size()\n        def totalCertifications = certifications.sum()\n        \n        def avgProductivity = productivityScores.sum() / productivityScores.size()\n        def totalProductivity = productivityScores.sum()\n        \n        def avgMarketValue = marketValues.sum() / marketValues.size()\n        def totalMarketValue = marketValues.sum()\n        \n        def avgReplacementCost = replacementCosts.sum() / replacementCosts.size()\n        def totalReplacementCost = replacementCosts.sum()\n        \n        def allSkills = employees*.skills.flatten()\n        def uniqueSkills = allSkills.toSet()\n        def skillFrequency = allSkills.countBy { it }\n        def topSkills = skillFrequency.sort { -it.value }.take(5)\n        \n        def salaryVarianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\n        def salaryVariance = salaryVarianceSum / salaries.size()\n        def salaryStdDeviation = Math.sqrt(salaryVariance)\n        \n        def performanceVariance = performances.collect { (it - avgPerformance) ** 2 }.sum() / performances.size()\n        def performanceStdDev = Math.sqrt(performanceVariance)\n        \n        def efficiencyScore = (avgPerformance / (avgSalary / 10000)) * 100\n        def costPerEmployee = totalCompensation / employees.size()\n        def valuePerEmployee = (totalProductivity * 10000) / employees.size()\n        \n        def juniorCount = employees.findAll { it.yearsOfService < 3 }.size()\n        def midCount = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\n        def seniorCount = employees.findAll { it.yearsOfService >= 7 }.size()\n        \n        def highPerformers = employees.findAll { it.performance >= 4.5 }.size()\n        def lowPerformers = employees.findAll { it.performance < 3.5 }.size()\n        \n        def promotionEligibleCount = employees.findAll { it.promotionEligibility }.size()\n        def riseEligibleCount = employees.findAll { it.riseEligibility }.size()\n        \n        def retentionRate = 100 - ((employees.findAll { it.yearsOfService < 1 }.size() / employees.size()) * 100)\n        \n        def trainingBudget = totalPayroll * 0.02\n        def recruitmentBudget = totalPayroll * 0.05\n        def developmentBudget = totalPayroll * 0.03\n        def totalDeptBudget = totalPayroll + totalBonuses + trainingBudget + recruitmentBudget + developmentBudget\n        \n        def averageLifetimeValue = employees*.lifetimeEarnings.sum() / employees.size()\n        def totalLifetimeValue = employees*.lifetimeEarnings.sum()\n        \n        def avgTrainingInvestment = employees*.trainingInvestment.sum() / employees.size()\n        def totalTrainingInvestment = employees*.trainingInvestment.sum()\n        \n        def avgROI = employees*.roi.sum() / employees.size()\n        \n        def bachelorsCount = employees.findAll { it.education == 'Bachelors' }.size()\n        def mastersCount = employees.findAll { it.education == 'Masters' }.size()\n        def phdCount = employees.findAll { it.education == 'PhD' }.size()\n        \n        departmentAnalytics[dept] = [\n            headcount: employees.size(),\n            avgSalary: avgSalary,\n            minSalary: minSalary,\n            maxSalary: maxSalary,\n            medianSalary: medianSalary,\n            salaryRange: salaryRange,\n            salaryStdDeviation: salaryStdDeviation,\n            totalPayroll: totalPayroll,\n            avgCompensation: avgCompensation,\n            totalCompensation: totalCompensation,\n            minCompensation: minCompensation,\n            maxCompensation: maxCompensation,\n            totalBonuses: totalBonuses,\n            avgBonus: avgBonus,\n            totalRetirement: totalRetirement,\n            totalStockOptions: totalStockOptions,\n            totalBenefits: totalBenefits,\n            avgPerformance: avgPerformance,\n            minPerformance: minPerformance,\n            maxPerformance: maxPerformance,\n            performanceRange: performanceRange,\n            performanceStdDev: performanceStdDev,\n            avgTenure: avgTenure,\n            minTenure: minTenure,\n            maxTenure: maxTenure,\n            tenureRange: tenureRange,\n            avgCertifications: avgCertifications,\n            totalCertifications: totalCertifications,\n            avgProductivity: avgProductivity,\n            totalProductivity: totalProductivity,\n            avgMarketValue: avgMarketValue,\n            totalMarketValue: totalMarketValue,\n            avgReplacementCost: avgReplacementCost,\n            totalReplacementCost: totalReplacementCost,\n            uniqueSkills: uniqueSkills.size(),\n            topSkills: topSkills,\n            skillDiversity: uniqueSkills.size() / employees.size(),\n            efficiencyScore: efficiencyScore,\n            costPerEmployee: costPerEmployee,\n            valuePerEmployee: valuePerEmployee,\n            juniorCount: juniorCount,\n            midCount: midCount,\n            seniorCount: seniorCount,\n            highPerformers: highPerformers,\n            lowPerformers: lowPerformers,\n            promotionEligible: promotionEligibleCount,\n            riseEligible: riseEligibleCount,\n            retentionRate: retentionRate,\n            trainingBudget: trainingBudget,\n            recruitmentBudget: recruitmentBudget,\n            developmentBudget: developmentBudget,\n            totalBudget: totalDeptBudget,\n            averageLifetimeValue: averageLifetimeValue,\n            totalLifetimeValue: totalLifetimeValue,\n            avgTrainingInvestment: avgTrainingInvestment,\n            totalTrainingInvestment: totalTrainingInvestment,\n            avgROI: avgROI,\n            bachelorsCount: bachelorsCount,\n            mastersCount: mastersCount,\n            phdCount: phdCount\n        ]\n    }\n    \n    def locationAnalytics = [:]\n    locationGroups.each { loc, employees ->\n        def salaries = employees*.baseSalary\n        def avgSalary = salaries.sum() / salaries.size()\n        def totalPayroll = salaries.sum()\n        def headcount = employees.size()\n        \n        def compensations = employees*.totalCompensation\n        def totalCompensation = compensations.sum()\n        def avgCompensation = totalCompensation / headcount\n        \n        def deptDistribution = employees.groupBy { it.department }.collectEntries { dept, emps -> [(dept): emps.size()] }\n        def avgPerformance = employees*.performance.sum() / employees.size()\n        def avgTenure = employees*.yearsOfService.sum() / employees.size()\n        def skillSet = employees*.skills.flatten().toSet()\n        \n        def costOfLivingMultiplier = loc == 'SF' ? 1.4 : (loc == 'NYC' ? 1.3 : (loc == 'LA' ? 1.2 : 1.0))\n        def adjustedCost = totalPayroll * costOfLivingMultiplier\n        def adjustedCompensation = totalCompensation * costOfLivingMultiplier\n        \n        def avgCertifications = employees*.certifications.sum() / employees.size()\n        def totalCertifications = employees*.certifications.sum()\n        \n        def educationDistribution = employees.groupBy { it.education }.collectEntries { edu, emps -> [(edu): emps.size()] }\n        \n        def juniors = employees.findAll { it.yearsOfService < 3 }.size()\n        def mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\n        def seniors = employees.findAll { it.yearsOfService >= 7 }.size()\n        \n        def highPerformers = employees.findAll { it.performance >= 4.5 }.size()\n        def avgPerformers = employees.findAll { it.performance >= 3.5 && it.performance < 4.5 }.size()\n        def lowPerformers = employees.findAll { it.performance < 3.5 }.size()\n        \n        def totalMarketValue = employees*.marketValue.sum()\n        def avgMarketValue = totalMarketValue / headcount\n        def marketCompetitiveness = (avgSalary / avgMarketValue) * 100\n        \n        def totalReplacementCost = employees*.replacementCost.sum()\n        def avgReplacementCost = totalReplacementCost / headcount\n        \n        def totalProductivity = employees*.productivityScore.sum()\n        def avgProductivity = totalProductivity / headcount\n        \n        locationAnalytics[loc] = [\n            headcount: headcount,\n            totalPayroll: totalPayroll,\n            avgSalary: avgSalary,\n            totalCompensation: totalCompensation,\n            avgCompensation: avgCompensation,\n            departmentDistribution: deptDistribution,\n            avgPerformance: avgPerformance,\n            avgTenure: avgTenure,\n            uniqueSkills: skillSet.size(),\n            costOfLiving: costOfLivingMultiplier,\n            adjustedCost: adjustedCost,\n            adjustedCompensation: adjustedCompensation,\n            avgCertifications: avgCertifications,\n            totalCertifications: totalCertifications,\n            educationDistribution: educationDistribution,\n            juniors: juniors,\n            mids: mids,\n            seniors: seniors,\n            highPerformers: highPerformers,\n            avgPerformers: avgPerformers,\n            lowPerformers: lowPerformers,\n            totalMarketValue: totalMarketValue,\n            avgMarketValue: avgMarketValue,\n            marketCompetitiveness: marketCompetitiveness,\n            totalReplacementCost: totalReplacementCost,\n            avgReplacementCost: avgReplacementCost,\n            totalProductivity: totalProductivity,\n            avgProductivity: avgProductivity\n        ]\n    }\n    \n    def companyMetrics = [:]\n    def allSalaries = enrichedEmployees*.baseSalary\n    def allCompensations = enrichedEmployees*.totalCompensation\n    def allPerformances = enrichedEmployees*.performance\n    def allTenures = enrichedEmployees*.yearsOfService\n    def allCertifications = enrichedEmployees*.certifications\n    def allProductivity = enrichedEmployees*.productivityScore\n    def allMarketValues = enrichedEmployees*.marketValue\n    def allReplacementCosts = enrichedEmployees*.replacementCost\n    \n    companyMetrics.totalEmployees = enrichedEmployees.size()\n    companyMetrics.totalPayroll = allSalaries.sum()\n    companyMetrics.totalCompensation = allCompensations.sum()\n    companyMetrics.totalBonuses = enrichedEmployees*.totalBonus.sum()\n    companyMetrics.totalRetirement = enrichedEmployees*.retirementContribution.sum()\n    companyMetrics.totalStockOptions = enrichedEmployees*.stockOptions.sum()\n    companyMetrics.totalBenefits = enrichedEmployees*.healthBenefits.sum()\n    \n    companyMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\n    companyMetrics.minSalary = allSalaries.min()\n    companyMetrics.maxSalary = allSalaries.max()\n    companyMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\n    companyMetrics.salaryRange = companyMetrics.maxSalary - companyMetrics.minSalary\n    \n    def salaryVariance = allSalaries.collect { (it - companyMetrics.avgSalary) ** 2 }.sum() / allSalaries.size()\n    companyMetrics.salaryStdDev = Math.sqrt(salaryVariance)\n    companyMetrics.salaryVariance = salaryVariance\n    \n    companyMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\n    companyMetrics.minCompensation = allCompensations.min()\n    companyMetrics.maxCompensation = allCompensations.max()\n    companyMetrics.medianCompensation = allCompensations.sort()[allCompensations.size().intdiv(2)]\n    \n    companyMetrics.avgPerformance = allPerformances.sum() / allPerformances.size()\n    companyMetrics.minPerformance = allPerformances.min()\n    companyMetrics.maxPerformance = allPerformances.max()\n    companyMetrics.medianPerformance = allPerformances.sort()[allPerformances.size().intdiv(2)]\n    \n    def performanceVariance = allPerformances.collect { (it - companyMetrics.avgPerformance) ** 2 }.sum() / allPerformances.size()\n    companyMetrics.performanceStdDev = Math.sqrt(performanceVariance)\n    \n    companyMetrics.avgTenure = allTenures.sum() / allTenures.size()\n    companyMetrics.minTenure = allTenures.min()\n    companyMetrics.maxTenure = allTenures.max()\n    companyMetrics.medianTenure = allTenures.sort()[allTenures.size().intdiv(2)]\n    \n    companyMetrics.avgCertifications = allCertifications.sum() / allCertifications.size()\n    companyMetrics.totalCertifications = allCertifications.sum()\n    \n    companyMetrics.totalProductivity = allProductivity.sum()\n    companyMetrics.avgProductivity = allProductivity.sum() / allProductivity.size()\n    \n    companyMetrics.totalMarketValue = allMarketValues.sum()\n    companyMetrics.avgMarketValue = allMarketValues.sum() / allMarketValues.size()\n    \n    companyMetrics.totalReplacementCost = allReplacementCosts.sum()\n    companyMetrics.avgReplacementCost = allReplacementCosts.sum() / allReplacementCosts.size()\n    \n    companyMetrics.totalLifetimeEarnings = enrichedEmployees*.lifetimeEarnings.sum()\n    companyMetrics.avgLifetimeEarnings = companyMetrics.totalLifetimeEarnings / enrichedEmployees.size()\n    \n    companyMetrics.totalTrainingInvestment = enrichedEmployees*.trainingInvestment.sum()\n    companyMetrics.avgTrainingInvestment = companyMetrics.totalTrainingInvestment / enrichedEmployees.size()\n    \n    companyMetrics.totalValueToCompany = enrichedEmployees*.valueToCompany.sum()\n    companyMetrics.avgValueToCompany = companyMetrics.totalValueToCompany / enrichedEmployees.size()\n    \n    companyMetrics.avgROI = enrichedEmployees*.roi.sum() / enrichedEmployees.size()\n    \n    def topPerformers = enrichedEmployees.sort { -it.performance }.take(10)\n    def bottomPerformers = enrichedEmployees.sort { it.performance }.take(5)\n    def highEarners = enrichedEmployees.sort { -it.baseSalary }.take(10)\n    def lowEarners = enrichedEmployees.sort { it.baseSalary }.take(5)\n    \n    def seniorEmployees = enrichedEmployees.findAll { it.yearsOfService >= 7 }\n    def midLevelEmployees = enrichedEmployees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }\n    def juniorEmployees = enrichedEmployees.findAll { it.yearsOfService < 3 }\n    \n    def highPerformers = enrichedEmployees.findAll { it.performance >= 4.5 }\n    def avgPerformers = enrichedEmployees.findAll { it.performance >= 3.5 && it.performance < 4.5 }\n    def lowPerformersAll = enrichedEmployees.findAll { it.performance < 3.5 }\n    \n    def promotionEligible = enrichedEmployees.findAll { it.promotionEligibility }\n    def riseEligible = enrichedEmployees.findAll { it.riseEligibility }\n    \n    companyMetrics.topPerformers = topPerformers*.name\n    companyMetrics.highEarners = highEarners*.name\n    companyMetrics.seniorCount = seniorEmployees.size()\n    companyMetrics.midLevelCount = midLevelEmployees.size()\n    companyMetrics.juniorCount = juniorEmployees.size()\n    companyMetrics.highPerformerCount = highPerformers.size()\n    companyMetrics.avgPerformerCount = avgPerformers.size()\n    companyMetrics.lowPerformerCount = lowPerformersAll.size()\n    companyMetrics.promotionEligibleCount = promotionEligible.size()\n    companyMetrics.riseEligibleCount = riseEligible.size()\n    \n    def bachelorsCount = enrichedEmployees.findAll { it.education == 'Bachelors' }.size()\n    def mastersCount = enrichedEmployees.findAll { it.education == 'Masters' }.size()\n    def phdCount = enrichedEmployees.findAll { it.education == 'PhD' }.size()\n    \n    companyMetrics.bachelorsCount = bachelorsCount\n    companyMetrics.mastersCount = mastersCount\n    companyMetrics.phdCount = phdCount\n    \n    def salaryBuckets = [\n        'under60k': enrichedEmployees.findAll { it.baseSalary < 60000 }.size(),\n        '60k-70k': enrichedEmployees.findAll { it.baseSalary >= 60000 && it.baseSalary < 70000 }.size(),\n        '70k-80k': enrichedEmployees.findAll { it.baseSalary >= 70000 && it.baseSalary < 80000 }.size(),\n        '80k-90k': enrichedEmployees.findAll { it.baseSalary >= 80000 && it.baseSalary < 90000 }.size(),\n        '90k-100k': enrichedEmployees.findAll { it.baseSalary >= 90000 && it.baseSalary < 100000 }.size(),\n        'over100k': enrichedEmployees.findAll { it.baseSalary >= 100000 }.size()\n    ]\n    \n    def performanceBuckets = [\n        'Excellent(4.5+)': enrichedEmployees.findAll { it.performance >= 4.5 }.size(),\n        'Good(4.0-4.5)': enrichedEmployees.findAll { it.performance >= 4.0 && it.performance < 4.5 }.size(),\n        'Average(3.5-4.0)': enrichedEmployees.findAll { it.performance >= 3.5 && it.performance < 4.0 }.size(),\n        'NeedsImprovement(<3.5)': enrichedEmployees.findAll { it.performance < 3.5 }.size()\n    ]\n    \n    def tenureBuckets = [\n        '0-1year': enrichedEmployees.findAll { it.yearsOfService < 1 }.size(),\n        '1-2years': enrichedEmployees.findAll { it.yearsOfService >= 1 && it.yearsOfService < 2 }.size(),\n        '2-3years': enrichedEmployees.findAll { it.yearsOfService >= 2 && it.yearsOfService < 3 }.size(),\n        '3-5years': enrichedEmployees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 5 }.size(),\n        '5-7years': enrichedEmployees.findAll { it.yearsOfService >= 5 && it.yearsOfService < 7 }.size(),\n        '7-10years': enrichedEmployees.findAll { it.yearsOfService >= 7 && it.yearsOfService < 10 }.size(),\n        '10+years': enrichedEmployees.findAll { it.yearsOfService >= 10 }.size()\n    ]\n    \n    def certificationBuckets = [\n        '0-1': enrichedEmployees.findAll { it.certifications <= 1 }.size(),\n        '2-3': enrichedEmployees.findAll { it.certifications >= 2 && it.certifications <= 3 }.size(),\n        '4-5': enrichedEmployees.findAll { it.certifications >= 4 && it.certifications <= 5 }.size(),\n        '6+': enrichedEmployees.findAll { it.certifications >= 6 }.size()\n    ]\n    \n    def skillAnalysis = [:]\n    def allSkillsList = enrichedEmployees*.skills.flatten()\n    def skillCounts = allSkillsList.countBy { it }\n    \n    skillAnalysis.totalUniqueSkills = skillCounts.size()\n    skillAnalysis.totalSkillInstances = allSkillsList.size()\n    skillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(15)\n    skillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedEmployees.size()\n    skillAnalysis.skillDistribution = skillCounts\n    \n    def techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala', 'Go', 'JavaScript', 'React', 'ML', 'AI', 'DevOps', 'Spring']\n    def techEmployees = enrichedEmployees.findAll { emp -> emp.skills.any { skill -> techSkills.contains(skill) } }\n    skillAnalysis.techEmployeeCount = techEmployees.size()\n    skillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedEmployees.size()) * 100\n    skillAnalysis.avgTechSalary = techEmployees*.baseSalary.sum() / techEmployees.size()\n    skillAnalysis.avgTechPerformance = techEmployees*.performance.sum() / techEmployees.size()\n    skillAnalysis.avgTechTenure = techEmployees*.yearsOfService.sum() / techEmployees.size()\n    \n    def businessSkills = ['CRM', 'Negotiation', 'Strategy', 'B2B', 'Enterprise', 'Contracts', 'Sales']\n    def businessEmployees = enrichedEmployees.findAll { emp -> emp.skills.any { skill -> businessSkills.contains(skill) } }\n    skillAnalysis.businessEmployeeCount = businessEmployees.size()\n    skillAnalysis.businessEmployeePercentage = (businessEmployees.size() / enrichedEmployees.size()) * 100\n    skillAnalysis.avgBusinessSalary = businessEmployees*.baseSalary.sum() / businessEmployees.size()\n    skillAnalysis.avgBusinessPerformance = businessEmployees*.performance.sum() / businessEmployees.size()\n    \n    def softSkills = ['Training', 'Benefits', 'Recruitment', 'HR', 'Compliance']\n    def softSkillEmployees = enrichedEmployees.findAll { emp -> emp.skills.any { skill -> softSkills.contains(skill) } }\n    skillAnalysis.softSkillEmployeeCount = softSkillEmployees.size()\n    skillAnalysis.avgSoftSkillSalary = softSkillEmployees*.baseSalary.sum() / softSkillEmployees.size()\n    \n    def compensationTiers = enrichedEmployees.collect { emp ->\n        def tier\n        if (emp.totalCompensation < 80000) tier = 'Tier1'\n        else if (emp.totalCompensation < 100000) tier = 'Tier2'\n        else if (emp.totalCompensation < 120000) tier = 'Tier3'\n        else if (emp.totalCompensation < 140000) tier = 'Tier4'\n        else tier = 'Tier5'\n        [employee: emp.name, tier: tier, compensation: emp.totalCompensation, department: emp.department]\n    }\n    def tierDistribution = compensationTiers.countBy { it.tier }\n    \n    def retentionRiskAnalysis = enrichedEmployees.collect { emp ->\n        def riskScore = 0\n        \n        if (emp.baseSalary < companyMetrics.avgSalary * 0.85) riskScore += 30\n        if (emp.baseSalary < emp.marketValue * 0.90) riskScore += 20\n        if (emp.performance < 4.0) riskScore += 15\n        if (emp.performance < 3.5) riskScore += 10\n        if (emp.yearsOfService < 2) riskScore += 25\n        if (emp.yearsOfService < 1) riskScore += 15\n        if (emp.totalBonus < companyMetrics.avgSalary * 0.1) riskScore += 10\n        if (emp.certifications < 2) riskScore += 10\n        if (emp.department == 'Sales' || emp.department == 'Marketing') riskScore += 5\n        \n        def risk = riskScore > 70 ? 'Critical' : (riskScore > 50 ? 'High' : (riskScore > 30 ? 'Medium' : 'Low'))\n        \n        [\n            employee: emp.name,\n            department: emp.department,\n            location: emp.location,\n            riskScore: riskScore,\n            risk: risk,\n            salary: emp.baseSalary,\n            marketValue: emp.marketValue,\n            performance: emp.performance,\n            tenure: emp.yearsOfService,\n            certifications: emp.certifications\n        ]\n    }\n    \n    def criticalRiskEmployees = retentionRiskAnalysis.findAll { it.risk == 'Critical' }\n    def highRiskEmployees = retentionRiskAnalysis.findAll { it.risk == 'High' }\n    def mediumRiskEmployees = retentionRiskAnalysis.findAll { it.risk == 'Medium' }\n    def lowRiskEmployees = retentionRiskAnalysis.findAll { it.risk == 'Low' }\n    \n    def projectedCosts = departmentGroups.collectEntries { dept, employees ->\n        def currentPayroll = employees*.baseSalary.sum()\n        def currentBonuses = employees*.totalBonus.sum()\n        def currentRetirement = employees*.retirementContribution.sum()\n        def currentStockOptions = employees*.stockOptions.sum()\n        def currentBenefits = employees*.healthBenefits.sum()\n        \n        def projectedRaises = currentPayroll * 0.03\n        def projectedBonuses = currentBonuses * 1.02\n        def projectedRetirement = currentRetirement * 1.03\n        def projectedStockOptions = currentStockOptions * 1.05\n        def projectedBenefits = currentBenefits * 1.04\n        \n        def projectedPayroll = currentPayroll + projectedRaises\n        def projectedTotal = projectedPayroll + projectedBonuses + projectedRetirement + projectedStockOptions + projectedBenefits\n        \n        def year2Payroll = projectedPayroll * 1.035\n        def year3Payroll = year2Payroll * 1.04\n        def year2Total = year2Payroll * 1.3\n        def year3Total = year3Payroll * 1.3\n        \n        [(dept): [\n            currentPayroll: currentPayroll,\n            currentBonuses: currentBonuses,\n            currentRetirement: currentRetirement,\n            currentStockOptions: currentStockOptions,\n            currentBenefits: currentBenefits,\n            projectedRaises: projectedRaises,\n            projectedBonuses: projectedBonuses,\n            projectedRetirement: projectedRetirement,\n            projectedStockOptions: projectedStockOptions,\n            projectedBenefits: projectedBenefits,\n            projectedPayroll: projectedPayroll,\n            projectedTotal: projectedTotal,\n            yearOverYearIncrease: projectedTotal - (currentPayroll + currentBonuses + currentRetirement + currentStockOptions + currentBenefits),\n            year2Payroll: year2Payroll,\n            year3Payroll: year3Payroll,\n            year2Total: year2Total,\n            year3Total: year3Total\n        ]]\n    }\n    \n    def benchmarkAnalysis = enrichedEmployees.collect { emp ->\n        def deptAvg = departmentAnalytics[emp.department].avgSalary\n        def companyAvg = companyMetrics.avgSalary\n        \n        def deptVariance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\n        def companyVariance = ((emp.baseSalary - companyAvg) / companyAvg) * 100\n        \n        def deptStatus = deptVariance > 10 ? 'Above' : (deptVariance < -10 ? 'Below' : 'OnPar')\n        def companyStatus = companyVariance > 10 ? 'Above' : (companyVariance < -10 ? 'Below' : 'OnPar')\n        \n        def marketComparison = emp.marketValue - emp.baseSalary\n        def marketGapPercentage = (marketComparison / emp.baseSalary) * 100\n        \n        [\n            employee: emp.name,\n            department: emp.department,\n            salary: emp.baseSalary,\n            deptAverage: deptAvg,\n            companyAverage: companyAvg,\n            deptVariancePercent: deptVariance,\n            companyVariancePercent: companyVariance,\n            deptStatus: deptStatus,\n            companyStatus: companyStatus,\n            marketValue: emp.marketValue,\n            marketGap: marketComparison,\n            marketGapPercent: marketGapPercentage\n        ]\n    }\n    \n    def performanceMetrics = enrichedEmployees.collect { emp ->\n        def efficiencyScore = (emp.totalCompensation / companyMetrics.avgCompensation) * 100\n        def tenureScore = (emp.yearsOfService / companyMetrics.avgTenure) * 100\n        def skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\n        def performanceScore = (emp.performance / companyMetrics.avgPerformance) * 100\n        def certificationScore = (emp.certifications / companyMetrics.avgCertifications) * 100\n        def productivityScore = (emp.productivityScore / companyMetrics.avgProductivity) * 100\n        \n        def overallScore = (efficiencyScore + tenureScore + skillScore + performanceScore + certificationScore + productivityScore) / 6\n        \n        def grade = overallScore >= 120 ? 'A+' : (overallScore >= 100 ? 'A' : (overallScore >= 85 ? 'B' : (overallScore >= 70 ? 'C' : 'D')))\n        \n        [\n            employee: emp.name,\n            efficiencyScore: efficiencyScore,\n            tenureScore: tenureScore,\n            skillScore: skillScore,\n            performanceScore: performanceScore,\n            certificationScore: certificationScore,\n            productivityScore: productivityScore,\n            overallScore: overallScore,\n            grade: grade\n        ]\n    }\n    \n    def topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(15)\n    def bottomPerformersByScore = performanceMetrics.sort { it.overallScore }.take(10)\n    \n    def salaryGrowthProjections = enrichedEmployees.collect { emp ->\n        def year1 = emp.baseSalary * 1.03\n        def year2 = year1 * 1.035\n        def year3 = year2 * 1.04\n        def year4 = year3 * 1.04\n        def year5 = year4 * 1.045\n        def year6 = year5 * 1.045\n        def year7 = year6 * 1.05\n        def year8 = year7 * 1.05\n        def year9 = year8 * 1.05\n        def year10 = year9 * 1.05\n        \n        def totalGrowth = year10 - emp.baseSalary\n        def growthPercentage = (totalGrowth / emp.baseSalary) * 100\n        \n        [\n            employee: emp.name,\n            currentSalary: emp.baseSalary,\n            year1: year1,\n            year2: year2,\n            year3: year3,\n            year4: year4,\n            year5: year5,\n            year6: year6,\n            year7: year7,\n            year8: year8,\n            year9: year9,\n            year10: year10,\n            totalGrowth: totalGrowth,\n            growthPercentage: growthPercentage\n        ]\n    }\n    \n    def departmentComparison = departmentAnalytics.collect { dept, stats ->\n        def efficiencyRatio = stats.totalPayroll / stats.headcount\n        def bonusRatio = stats.totalBonuses / stats.totalPayroll\n        def performanceIndex = (stats.avgPerformance / companyMetrics.avgPerformance) * 100\n        def retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / stats.headcount) * 100)\n        def growthPotential = stats.promotionEligible / stats.headcount * 100\n        def productivityIndex = (stats.avgProductivity / companyMetrics.avgProductivity) * 100\n        def costEfficiency = stats.valuePerEmployee / stats.costPerEmployee\n        def marketCompetitiveness = (stats.avgSalary / stats.avgMarketValue) * 100\n        \n        [\n            department: dept,\n            headcount: stats.headcount,\n            efficiencyRatio: efficiencyRatio,\n            bonusRatio: bonusRatio,\n            avgPerformance: stats.avgPerformance,\n            performanceIndex: performanceIndex,\n            retentionScore: retentionScore,\n            avgTenure: stats.avgTenure,\n            growthPotential: growthPotential,\n            productivityIndex: productivityIndex,\n            costEfficiency: costEfficiency,\n            marketCompetitiveness: marketCompetitiveness\n        ]\n    }\n    \n    def skillGapAnalysis = departmentGroups.collect { dept, employees ->\n        def deptSkills = employees*.skills.flatten().toSet()\n        def missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n        def missingBusinessSkills = businessSkills.findAll { !deptSkills.contains(it) }\n        def avgSkillCount = employees*.skillCount.sum() / employees.size()\n        def skillDeficit = skillAnalysis.avgSkillsPerEmployee - avgSkillCount\n        def trainingRequired = employees.findAll { it.skillCount < avgSkillCount }.size()\n        \n        [\n            department: dept,\n            currentSkills: deptSkills.size(),\n            avgSkillsPerPerson: avgSkillCount,\n            skillDeficit: skillDeficit,\n            missingTechSkills: missingTechSkills,\n            missingBusinessSkills: missingBusinessSkills,\n            trainingRequired: trainingRequired\n        ]\n    }\n    \n    def costOptimization = enrichedEmployees.findAll { emp ->\n        emp.baseSalary > departmentAnalytics[emp.department].avgSalary * 1.15 && emp.performance < 4.0\n    }.collect { emp ->\n        def targetSalary = departmentAnalytics[emp.department].avgSalary\n        def potentialSavings = emp.baseSalary - targetSalary\n        def adjustedTarget = targetSalary * (emp.performance / companyMetrics.avgPerformance)\n        def optimalSavings = emp.baseSalary - adjustedTarget\n        \n        [\n            employee: emp.name,\n            department: emp.department,\n            currentSalary: emp.baseSalary,\n            targetSalary: targetSalary,\n            adjustedTarget: adjustedTarget,\n            potentialSavings: potentialSavings,\n            optimalSavings: optimalSavings,\n            performance: emp.performance\n        ]\n    }\n    \n    def diversityMetrics = departmentGroups.collect { dept, employees ->\n        def skillDiversity = employees*.skills.flatten().toSet().size()\n        def salarySpread = departmentAnalytics[dept].salaryRange\n        def performanceSpread = departmentAnalytics[dept].maxPerformance - departmentAnalytics[dept].minPerformance\n        def tenureSpread = departmentAnalytics[dept].maxTenure - departmentAnalytics[dept].minTenure\n        def educationDiversity = employees*.education.toSet().size()\n        def locationDiversity = employees*.location.toSet().size()\n        \n        [\n            department: dept,\n            skillDiversity: skillDiversity,\n            salarySpread: salarySpread,\n            performanceSpread: performanceSpread,\n            tenureSpread: tenureSpread,\n            educationDiversity: educationDiversity,\n            locationDiversity: locationDiversity\n        ]\n    }\n    \n    def attritionAnalysis = enrichedEmployees.collect { emp ->\n        def attritionRisk = 0\n        \n        if (emp.yearsOfService < 2) attritionRisk += 30\n        if (emp.yearsOfService < 1) attritionRisk += 20\n        if (emp.baseSalary < companyMetrics.avgSalary * 0.9) attritionRisk += 25\n        if (emp.baseSalary < emp.marketValue * 0.9) attritionRisk += 15\n        if (emp.performance < 4.0) attritionRisk += 20\n        if (emp.performance < 3.5) attritionRisk += 15\n        if (emp.skillCount < 2) attritionRisk += 15\n        if (emp.certifications < 2) attritionRisk += 10\n        if (emp.totalBonus < companyMetrics.avgSalary * 0.1) attritionRisk += 10\n        if (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 10\n        \n        def riskLevel = attritionRisk > 80 ? 'Critical' : (attritionRisk > 60 ? 'High' : (attritionRisk > 40 ? 'Medium' : (attritionRisk > 20 ? 'Low' : 'Minimal')))\n        \n        def replacementImpact = emp.replacementCost + emp.trainingInvestment\n        def knowledgeLossImpact = emp.yearsOfService * 10000\n        def totalAttritionCost = replacementImpact + knowledgeLossImpact\n        \n        [\n            employee: emp.name,\n            department: emp.department,\n            attritionRisk: attritionRisk,\n            riskLevel: riskLevel,\n            tenure: emp.yearsOfService,\n            performance: emp.performance,\n            salary: emp.baseSalary,\n            marketValue: emp.marketValue,\n            replacementCost: emp.replacementCost,\n            totalAttritionCost: totalAttritionCost\n        ]\n    }\n    \n    def criticalAttrition = attritionAnalysis.findAll { it.riskLevel == 'Critical' }\n    def highAttrition = attritionAnalysis.findAll { it.riskLevel == 'High' }\n    def totalAttritionRisk = (criticalAttrition + highAttrition)*.totalAttritionCost.sum() ?: 0\n    \n    def trainingNeeds = departmentGroups.collect { dept, employees ->\n        def avgSkills = employees*.skillCount.sum() / employees.size()\n        def needsTraining = employees.findAll { it.skillCount < avgSkills }\n        def lowPerformers = employees.findAll { it.performance < 4.0 }\n        def lowCertifications = employees.findAll { it.certifications < 2 }\n        \n        def trainingCandidates = (needsTraining + lowPerformers + lowCertifications).unique { it.id }\n        def trainingCost = trainingCandidates.size() * 5000\n        def expectedProductivityGain = trainingCandidates.size() * 15000\n        def roi = trainingCost > 0 ? ((expectedProductivityGain - trainingCost) / trainingCost) * 100 : 0\n        \n        [\n            department: dept,\n            avgSkillCount: avgSkills,\n            employeesNeedingTraining: trainingCandidates.size(),\n            lowPerformers: lowPerformers.size(),\n            lowCertifications: lowCertifications.size(),\n            estimatedTrainingCost: trainingCost,\n            expectedProductivityGain: expectedProductivityGain,\n            roi: roi\n        ]\n    }\n    \n    def budgetAllocation = departmentAnalytics.collect { dept, stats ->\n        def payroll = stats.totalPayroll\n        def bonuses = stats.totalBonuses\n        def training = stats.trainingBudget\n        def recruitment = stats.recruitmentBudget\n        def development = stats.developmentBudget\n        def benefits = stats.totalBenefits\n        def retirement = stats.totalRetirement\n        def stockOptions = stats.totalStockOptions\n        def overhead = (payroll + bonuses) * 0.15\n        def technology = payroll * 0.10\n        def facilities = stats.headcount * 5000\n        def total = payroll + bonuses + training + recruitment + development + benefits + retirement + stockOptions + overhead + technology + facilities\n        \n        [\n            department: dept,\n            payroll: payroll,\n            bonuses: bonuses,\n            training: training,\n            recruitment: recruitment,\n            development: development,\n            benefits: benefits,\n            retirement: retirement,\n            stockOptions: stockOptions,\n            overhead: overhead,\n            technology: technology,\n            facilities: facilities,\n            total: total\n        ]\n    }\n    \n    def competencyMatrix = enrichedEmployees.collect { emp ->\n        def technicalScore = emp.skillCount * 20\n        def experienceScore = emp.yearsOfService * 10\n        def performanceScore = emp.performance * 20\n        def certificationScore = emp.certifications * 15\n        def educationScore = emp.education == 'PhD' ? 100 : (emp.education == 'Masters' ? 80 : 60)\n        def compensationLevel = (emp.baseSalary / companyMetrics.maxSalary) * 100\n        def productivityScore = (emp.productivityScore / companyMetrics.avgProductivity) * 50\n        \n        def overallCompetency = (technicalScore + experienceScore + performanceScore + certificationScore + educationScore + productivityScore) / 6\n        def grade = overallCompetency >= 90 ? 'A+' : (overallCompetency >= 80 ? 'A' : (overallCompetency >= 70 ? 'B+' : (overallCompetency >= 60 ? 'B' : (overallCompetency >= 50 ? 'C' : 'D'))))\n        \n        [\n            employee: emp.name,\n            technical: technicalScore,\n            experience: experienceScore,\n            performance: performanceScore,\n            certification: certificationScore,\n            education: educationScore,\n            compensation: compensationLevel,\n            productivity: productivityScore,\n            overall: overallCompetency,\n            grade: grade\n        ]\n    }\n    \n    def successorPlanning = seniorEmployees.collect { emp ->\n        def potentialSuccessors = enrichedEmployees.findAll {\n            it.department == emp.department &&\n            it.yearsOfService >= 3 &&\n            it.yearsOfService < emp.yearsOfService &&\n            it.performance >= 4.0 &&\n            it.skillCount >= 2\n        }\n        \n        def readySuccessors = potentialSuccessors.findAll {\n            it.yearsOfService >= 5 &&\n            it.performance >= 4.5 &&\n            it.certifications >= 3\n        }\n        \n        def emergingSuccessors = potentialSuccessors.findAll {\n            it.yearsOfService >= 3 &&\n            it.performance >= 4.3 &&\n            it.certifications >= 2 &&\n            !readySuccessors.contains(it)\n        }\n        \n        def successionRisk = readySuccessors.size() == 0 ? 'High' : (readySuccessors.size() == 1 ? 'Medium' : 'Low')\n        \n        [\n            seniorEmployee: emp.name,\n            position: emp.department,\n            yearsOfService: emp.yearsOfService,\n            potentialSuccessors: potentialSuccessors*.name,\n            readySuccessors: readySuccessors*.name,\n            emergingSuccessors: emergingSuccessors*.name,\n            successionRisk: successionRisk,\n            successorCount: potentialSuccessors.size()\n        ]\n    }\n    \n    def marketComparison = enrichedEmployees.collect { emp ->\n        def marketRate = emp.baseSalary * 1.15\n        def marketRateWithPerf = emp.marketValue\n        def industryAvg = emp.baseSalary * 1.10\n        \n        def gap = marketRate - emp.baseSalary\n        def perfGap = marketRateWithPerf - emp.baseSalary\n        def industryGap = industryAvg - emp.baseSalary\n        \n        def competitive = gap < emp.baseSalary * 0.1\n        def perfCompetitive = perfGap < emp.baseSalary * 0.15\n        \n        [\n            employee: emp.name,\n            department: emp.department,\n            currentSalary: emp.baseSalary,\n            marketRate: marketRate,\n            performanceAdjustedMarket: marketRateWithPerf,\n            industryAverage: industryAvg,\n            gap: gap,\n            performanceGap: perfGap,\n            industryGap: industryGap,\n            competitive: competitive,\n            perfCompetitive: perfCompetitive\n        ]\n    }\n    \n    def quarterlyForecasts = (1..4).collect { quarter ->\n        def quarterPayroll = companyMetrics.totalPayroll * (1 + (quarter * 0.01))\n        def quarterBonuses = companyMetrics.totalBonuses / 4\n        def quarterBenefits = enrichedEmployees.size() * 3000\n        def quarterRetirement = quarterPayroll * 0.06\n        def quarterStockOptions = quarterPayroll * 0.08\n        def quarterTraining = quarterPayroll * 0.005\n        def quarterTotal = quarterPayroll + quarterBonuses + quarterBenefits + quarterRetirement + quarterStockOptions + quarterTraining\n        \n        [\n            quarter: \"Q$quarter\",\n            payroll: quarterPayroll,\n            bonuses: quarterBonuses,\n            benefits: quarterBenefits,\n            retirement: quarterRetirement,\n            stockOptions: quarterStockOptions,\n            training: quarterTraining,\n            total: quarterTotal\n        ]\n    }\n    \n    def yearlyForecasts = (1..10).collect { year ->\n        def growthRate = 1 + (0.03 * year * 0.95)\n        def forecastPayroll = companyMetrics.totalPayroll * Math.pow(1.03, year)\n        def forecastBonuses = companyMetrics.totalBonuses * Math.pow(1.02, year)\n        def forecastHeadcount = Math.ceil(enrichedEmployees.size() * Math.pow(1.05, year))\n        def forecastBenefits = forecastHeadcount * 12000 * Math.pow(1.04, year)\n        def forecastRetirement = forecastPayroll * 0.06\n        def forecastStockOptions = forecastPayroll * 0.08\n        def forecastTotal = forecastPayroll + forecastBonuses + forecastBenefits + forecastRetirement + forecastStockOptions\n        \n        [\n            year: \"Year$year\",\n            payroll: forecastPayroll,\n            bonuses: forecastBonuses,\n            headcount: forecastHeadcount,\n            benefits: forecastBenefits,\n            retirement: forecastRetirement,\n            stockOptions: forecastStockOptions,\n            total: forecastTotal\n        ]\n    }\n    \n    def productivityMetrics = enrichedEmployees.collect { emp ->\n        def outputPerDollar = emp.yearsOfService * emp.skillCount * emp.performance / (emp.baseSalary / 10000)\n        def efficiencyRating = outputPerDollar > 10 ? 'Excellent' : (outputPerDollar > 7 ? 'Good' : (outputPerDollar > 4 ? 'Average' : 'Poor'))\n        def valueScore = (emp.performance * emp.skillCount * 1000) / emp.baseSalary\n        def roiScore = emp.roi\n        def productivityIndex = (emp.productivityScore / companyMetrics.avgProductivity) * 100\n        \n        [\n            employee: emp.name,\n            productivity: outputPerDollar,\n            efficiencyRating: efficiencyRating,\n            valueScore: valueScore,\n            roiScore: roiScore,\n            productivityIndex: productivityIndex\n        ]\n    }\n    \n    def teamComposition = departmentGroups.collect { dept, employees ->\n        def juniors = employees.findAll { it.yearsOfService < 3 }.size()\n        def mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\n        def seniors = employees.findAll { it.yearsOfService >= 7 }.size()\n        def avgAge = employees*.yearsOfService.sum() / employees.size()\n        \n        def balance = [\n            juniors: juniors,\n            mids: mids,\n            seniors: seniors,\n            total: employees.size(),\n            avgTenure: avgAge\n        ]\n        \n        def isBalanced = juniors > 0 && mids > 0 && seniors > 0\n        def juniorRatio = juniors / employees.size()\n        def midRatio = mids / employees.size()\n        def seniorRatio = seniors / employees.size()\n        \n        [\n            department: dept,\n            composition: balance,\n            balanced: isBalanced,\n            juniorRatio: juniorRatio,\n            midRatio: midRatio,\n            seniorRatio: seniorRatio\n        ]\n    }\n    \n    def enrichedProjects = projectData.collect { proj ->\n        def teamMembers = enrichedEmployees.findAll { emp -> proj.team.contains(emp.id) }\n        def teamSalaries = teamMembers*.baseSalary.sum()\n        def teamCompensation = teamMembers*.totalCompensation.sum()\n        def teamPerformance = teamMembers*.performance.sum() / teamMembers.size()\n        def teamSkills = teamMembers*.skills.flatten().toSet()\n        def teamTenure = teamMembers*.yearsOfService.sum() / teamMembers.size()\n        def teamCertifications = teamMembers*.certifications.sum()\n        def teamProductivity = teamMembers*.productivityScore.sum()\n        \n        def utilizationRate = (teamMembers.size() / enrichedEmployees.size()) * 100\n        def costPerMonth = teamSalaries / 12\n        def totalCostPerMonth = teamCompensation / 12\n        \n        def startDate = LocalDate.parse(proj.startDate, formatter)\n        def endDate = LocalDate.parse(proj.endDate, formatter)\n        def durationMonths = ChronoUnit.MONTHS.between(startDate, endDate)\n        def totalProjectCost = totalCostPerMonth * durationMonths\n        def budgetUtilization = (totalProjectCost / proj.budget) * 100\n        def budgetRemaining = proj.budget - totalProjectCost\n        \n        def riskScore = 0\n        if (budgetUtilization > 90) riskScore += 30\n        if (teamPerformance < 4.0) riskScore += 20\n        if (teamTenure < 3) riskScore += 15\n        if (teamMembers.size() < 3) riskScore += 25\n        def projectRisk = riskScore > 50 ? 'High' : (riskScore > 30 ? 'Medium' : 'Low')\n        \n        [\n            id: proj.id,\n            name: proj.name,\n            budget: proj.budget,\n            status: proj.status,\n            priority: proj.priority,\n            startDate: startDate,\n            endDate: endDate,\n            durationMonths: durationMonths,\n            teamSize: teamMembers.size(),\n            teamMembers: teamMembers*.name,\n            teamSalaries: teamSalaries,\n            teamCompensation: teamCompensation,\n            avgTeamPerformance: teamPerformance,\n            teamSkills: teamSkills.size(),\n            avgTeamTenure: teamTenure,\n            teamCertifications: teamCertifications,\n            teamProductivity: teamProductivity,\n            utilizationRate: utilizationRate,\n            monthlyCost: costPerMonth,\n            totalMonthlyCost: totalCostPerMonth,\n            totalProjectCost: totalProjectCost,\n            budgetUtilization: budgetUtilization,\n            budgetRemaining: budgetRemaining,\n            projectRisk: projectRisk,\n            riskScore: riskScore\n        ]\n    }\n    \n    def projectAnalytics = [:]\n    def activeProjects = enrichedProjects.findAll { it.status == 'Active' }\n    def completedProjects = enrichedProjects.findAll { it.status == 'Completed' }\n    def planningProjects = enrichedProjects.findAll { it.status == 'Planning' }\n    \n    projectAnalytics.totalProjects = enrichedProjects.size()\n    projectAnalytics.activeProjects = activeProjects.size()\n    projectAnalytics.completedProjects = completedProjects.size()\n    projectAnalytics.planningProjects = planningProjects.size()\n    \n    projectAnalytics.totalBudget = enrichedProjects*.budget.sum()\n    projectAnalytics.activeBudget = activeProjects*.budget.sum()\n    projectAnalytics.completedBudget = completedProjects*.budget.sum()\n    \n    projectAnalytics.totalProjectCost = enrichedProjects*.totalProjectCost.sum()\n    projectAnalytics.avgProjectCost = projectAnalytics.totalProjectCost / enrichedProjects.size()\n    projectAnalytics.totalBudgetUtilization = (projectAnalytics.totalProjectCost / projectAnalytics.totalBudget) * 100\n    \n    projectAnalytics.avgTeamSize = enrichedProjects*.teamSize.sum() / enrichedProjects.size()\n    projectAnalytics.avgBudget = projectAnalytics.totalBudget / enrichedProjects.size()\n    projectAnalytics.avgDuration = enrichedProjects*.durationMonths.sum() / enrichedProjects.size()\n    \n    def projectByPriority = enrichedProjects.groupBy { it.priority }\n    projectAnalytics.highPriorityCount = projectByPriority['High']?.size() ?: 0\n    projectAnalytics.mediumPriorityCount = projectByPriority['Medium']?.size() ?: 0\n    projectAnalytics.lowPriorityCount = projectByPriority['Low']?.size() ?: 0\n    \n    def highRiskProjects = enrichedProjects.findAll { it.projectRisk == 'High' }\n    projectAnalytics.highRiskProjectCount = highRiskProjects.size()\n    projectAnalytics.highRiskProjectNames = highRiskProjects*.name\n    \n    def resourceAllocation = enrichedEmployees.collect { emp ->\n        def assignedProjects = enrichedProjects.findAll { proj -> proj.teamMembers.contains(emp.name) }\n        def projectCount = assignedProjects.size()\n        def totalProjectBudget = assignedProjects*.budget.sum() ?: 0\n        def utilizationScore = projectCount * 25\n        def status = projectCount > 2 ? 'Overallocated' : (projectCount > 0 ? 'Allocated' : 'Available')\n        \n        [\n            employee: emp.name,\n            department: emp.department,\n            assignedProjects: projectCount,\n            projectNames: assignedProjects*.name,\n            totalBudget: totalProjectBudget,\n            utilizationScore: utilizationScore,\n            status: status\n        ]\n    }\n    \n    def availableResources = resourceAllocation.findAll { it.status == 'Available' }\n    def allocatedResources = resourceAllocation.findAll { it.status == 'Allocated' }\n    def overallocatedResources = resourceAllocation.findAll { it.status == 'Overallocated' }\n    \n    def careerPathAnalysis = enrichedEmployees.collect { emp ->\n        def currentLevel = emp.yearsOfService < 3 ? 'Junior' : (emp.yearsOfService < 7 ? 'Mid' : (emp.yearsOfService < 12 ? 'Senior' : 'Principal'))\n        def nextLevel = currentLevel == 'Junior' ? 'Mid' : (currentLevel == 'Mid' ? 'Senior' : (currentLevel == 'Senior' ? 'Principal' : 'Executive'))\n        \n        def timeToPromotion = 0\n        if (currentLevel == 'Junior') timeToPromotion = 3 - emp.yearsOfService\n        else if (currentLevel == 'Mid') timeToPromotion = 7 - emp.yearsOfService\n        else if (currentLevel == 'Senior') timeToPromotion = 12 - emp.yearsOfService\n        \n        def promotionReady = emp.performance >= 4.0 && timeToPromotion <= 0 && emp.certifications >= 2\n        def skillGap = currentLevel == 'Junior' ? 1 : (currentLevel == 'Mid' ? 2 : (currentLevel == 'Senior' ? 1 : 0))\n        def certificationGap = currentLevel == 'Junior' ? 1 : (currentLevel == 'Mid' ? 1 : (currentLevel == 'Senior' ? 2 : 0))\n        \n        def expectedSalaryIncrease = currentLevel == 'Junior' ? 15000 : (currentLevel == 'Mid' ? 20000 : (currentLevel == 'Senior' ? 25000 : 30000))\n        \n        [\n            employee: emp.name,\n            currentLevel: currentLevel,\n            nextLevel: nextLevel,\n            yearsOfService: emp.yearsOfService,\n            timeToPromotion: Math.max(0, timeToPromotion),\n            promotionReady: promotionReady,\n            requiredSkills: skillGap,\n            currentSkills: emp.skillCount,\n            requiredCertifications: certificationGap,\n            currentCertifications: emp.certifications,\n            performance: emp.performance,\n            expectedSalaryIncrease: expectedSalaryIncrease\n        ]\n    }\n    \n    def promotionReadyCandidates = careerPathAnalysis.findAll { it.promotionReady }\n    \n    def compensationEquityAnalysis = enrichedEmployees.collect { emp ->\n        def peers = enrichedEmployees.findAll {\n            it.department == emp.department &&\n            it.yearsOfService >= emp.yearsOfService - 1 &&\n            it.yearsOfService <= emp.yearsOfService + 1 &&\n            it.id != emp.id\n        }\n        \n        def avgPeerSalary = peers ? peers*.baseSalary.sum() / peers.size() : emp.baseSalary\n        def avgPeerCompensation = peers ? peers*.totalCompensation.sum() / peers.size() : emp.totalCompensation\n        \n        def equityGap = emp.baseSalary - avgPeerSalary\n        def equityRatio = avgPeerSalary > 0 ? (emp.baseSalary / avgPeerSalary) * 100 : 100\n        def compensationGap = emp.totalCompensation - avgPeerCompensation\n        \n        def status = equityRatio < 90 ? 'Significantly Underpaid' : (equityRatio < 95 ? 'Underpaid' : (equityRatio > 110 ? 'Significantly Overpaid' : (equityRatio > 105 ? 'Overpaid' : 'Fair')))\n        \n        [\n            employee: emp.name,\n            salary: emp.baseSalary,\n            totalCompensation: emp.totalCompensation,\n            peerAverage: avgPeerSalary,\n            peerCompensation: avgPeerCompensation,\n            equityGap: equityGap,\n            compensationGap: compensationGap,\n            equityRatio: equityRatio,\n            status: status,\n            peerCount: peers.size()\n        ]\n    }\n    \n    def underpaidEmployees = compensationEquityAnalysis.findAll { it.status.contains('Underpaid') }\n    def overpaidEmployees = compensationEquityAnalysis.findAll { it.status.contains('Overpaid') }\n    \n    def trainingROIAnalysis = trainingNeeds.collect { dept ->\n        def deptEmployees = departmentGroups[dept.department]\n        def avgSalary = deptEmployees*.baseSalary.sum() / deptEmployees.size()\n        def avgPerformance = deptEmployees*.performance.sum() / deptEmployees.size()\n        \n        def expectedPerformanceGain = 0.25\n        def expectedProductivityGain = dept.expectedProductivityGain\n        def expectedSalaryImpact = avgSalary * expectedPerformanceGain * 0.15\n        def trainingCost = dept.estimatedTrainingCost\n        def expectedRevenue = expectedProductivityGain * 2\n        \n        def roi = trainingCost > 0 ? ((expectedRevenue - trainingCost) / trainingCost) * 100 : 0\n        def paybackPeriod = expectedRevenue > 0 ? trainingCost / (expectedRevenue / 12) : 0\n        \n        def recommendation = roi > 100 ? 'Strongly Recommend' : (roi > 50 ? 'Recommend' : (roi > 0 ? 'Consider' : 'Review'))\n        \n        [\n            department: dept.department,\n            trainingCost: trainingCost,\n            candidateCount: dept.employeesNeedingTraining,\n            expectedProductivityGain: expectedProductivityGain,\n            expectedRevenue: expectedRevenue,\n            roi: roi,\n            paybackPeriod: paybackPeriod,\n            recommendation: recommendation\n        ]\n    }\n    \n    def turnoverImpactAnalysis = retentionRiskAnalysis.collect { risk ->\n        def employee = enrichedEmployees.find { it.name == risk.employee }\n        def replacementCost = employee.baseSalary * 0.5\n        def recruitmentCost = 15000\n        def trainingCost = 20000\n        def onboardingCost = 10000\n        def productivityLoss = employee.baseSalary * 0.3\n        def knowledgeLoss = employee.yearsOfService * 5000\n        def totalImpact = replacementCost + recruitmentCost + trainingCost + onboardingCost + productivityLoss + knowledgeLoss\n        \n        [\n            employee: risk.employee,\n            riskLevel: risk.risk,\n            salary: risk.salary,\n            tenure: risk.tenure,\n            replacementCost: replacementCost,\n            recruitmentCost: recruitmentCost,\n            trainingCost: trainingCost,\n            onboardingCost: onboardingCost,\n            productivityLoss: productivityLoss,\n            knowledgeLoss: knowledgeLoss,\n            totalImpact: totalImpact\n        ]\n    }\n    \n    def highImpactRisks = turnoverImpactAnalysis.findAll { it.riskLevel == 'High' || it.riskLevel == 'Critical' }\n    def totalTurnoverRisk = highImpactRisks*.totalImpact.sum() ?: 0\n    \n    def workforceSegmentation = enrichedEmployees.collect { emp ->\n        def segment\n        if (emp.performance >= 4.5 && emp.baseSalary >= companyMetrics.avgSalary * 1.2) segment = 'HighPerformer-HighPay'\n        else if (emp.performance >= 4.5 && emp.baseSalary < companyMetrics.avgSalary) segment = 'HighPerformer-LowPay'\n        else if (emp.performance < 4.0 && emp.baseSalary >= companyMetrics.avgSalary * 1.2) segment = 'LowPerformer-HighPay'\n        else if (emp.performance < 4.0 && emp.baseSalary < companyMetrics.avgSalary) segment = 'LowPerformer-LowPay'\n        else if (emp.performance >= 4.0 && emp.baseSalary >= companyMetrics.avgSalary) segment = 'Average-HighPay'\n        else segment = 'Average-LowPay'\n        \n        def action = segment.contains('LowPay') && segment.contains('High') ? 'Increase Compensation' :\n                     (segment.contains('HighPay') && segment.contains('Low') ? 'Performance Improvement Plan' : 'Maintain')\n        \n        [\n            employee: emp.name,\n            segment: segment,\n            performance: emp.performance,\n            salary: emp.baseSalary,\n            action: action\n        ]\n    }\n    \n    def segmentDistribution = workforceSegmentation.countBy { it.segment }\n    \n    def benchmarkComparisons = departmentAnalytics.collect { dept, stats ->\n        def industryAvgSalary = stats.avgSalary * 1.08\n        def industryAvgPerformance = 4.2\n        def industryAvgTenure = 5.5\n        def industryAvgCertifications = 2.5\n        \n        def salaryCompetitiveness = (stats.avgSalary / industryAvgSalary) * 100\n        def performanceCompetitiveness = (stats.avgPerformance / industryAvgPerformance) * 100\n        def tenureCompetitiveness = (stats.avgTenure / industryAvgTenure) * 100\n        def certificationCompetitiveness = (stats.avgCertifications / industryAvgCertifications) * 100\n        \n        def overallCompetitiveness = (salaryCompetitiveness + performanceCompetitiveness + tenureCompetitiveness + certificationCompetitiveness) / 4\n        \n        [\n            department: dept,\n            avgSalary: stats.avgSalary,\n            industryAvgSalary: industryAvgSalary,\n            salaryCompetitiveness: salaryCompetitiveness,\n            avgPerformance: stats.avgPerformance,\n            industryAvgPerformance: industryAvgPerformance,\n            performanceCompetitiveness: performanceCompetitiveness,\n            avgTenure: stats.avgTenure,\n            industryAvgTenure: industryAvgTenure,\n            tenureCompetitiveness: tenureCompetitiveness,\n            avgCertifications: stats.avgCertifications,\n            industryAvgCertifications: industryAvgCertifications,\n            certificationCompetitiveness: certificationCompetitiveness,\n            overallCompetitiveness: overallCompetitiveness\n        ]\n    }\n    \n    def longTermStrategicPlan = (1..15).collect { year ->\n        def targetHeadcount = Math.ceil(enrichedEmployees.size() * Math.pow(1.08, year))\n        def targetPayroll = companyMetrics.totalPayroll * Math.pow(1.04, year)\n        def targetCompensation = companyMetrics.totalCompensation * Math.pow(1.045, year)\n        def targetRevenue = targetPayroll * 3.5\n        def targetProfit = targetRevenue * 0.18\n        def investmentNeeded = targetHeadcount * 50000\n        def trainingInvestment = targetPayroll * 0.02\n        def technologyInvestment = targetPayroll * 0.10\n        def facilitiesInvestment = targetHeadcount * 5000\n        def totalInvestment = investmentNeeded + trainingInvestment + technologyInvestment + facilitiesInvestment\n        \n        [\n            year: year,\n            targetHeadcount: targetHeadcount,\n            targetPayroll: targetPayroll,\n            targetCompensation: targetCompensation,\n            targetRevenue: targetRevenue,\n            targetProfit: targetProfit,\n            investmentNeeded: investmentNeeded,\n            trainingInvestment: trainingInvestment,\n            technologyInvestment: technologyInvestment,\n            facilitiesInvestment: facilitiesInvestment,\n            totalInvestment: totalInvestment\n        ]\n    }\n    \n    def trainingProgramAnalysis = trainingPrograms.collect { program ->\n        def eligibleEmployees = enrichedEmployees.findAll { emp ->\n            program.name.contains('Leadership') ? emp.yearsOfService >= 3 && emp.performance >= 4.0 :\n            program.name.contains('Technical') ? emp.department == 'Engineering' && emp.performance >= 3.8 :\n            program.name.contains('Sales') ? emp.department == 'Sales' :\n            program.name.contains('Financial') ? emp.department == 'Finance' :\n            program.name.contains('Marketing') ? emp.department == 'Marketing' :\n            program.name.contains('HR') ? emp.department == 'HR' :\n            program.name.contains('Cloud') ? emp.skills.any { it in ['AWS', 'Docker', 'Kubernetes'] } :\n            program.name.contains('Data') ? emp.skills.any { it in ['Python', 'SQL', 'Spark'] } :\n            true\n        }\n        \n        def recommendedEmployees = eligibleEmployees.findAll { it.performance < 4.5 || it.certifications < 3 }.take(program.capacity)\n        def totalCost = recommendedEmployees.size() * program.cost\n        def expectedBenefit = recommendedEmployees.size() * 20000\n        def roi = totalCost > 0 ? ((expectedBenefit - totalCost) / totalCost) * 100 : 0\n        \n        [\n            programId: program.id,\n            programName: program.name,\n            duration: program.duration,\n            costPerPerson: program.cost,\n            capacity: program.capacity,\n            eligibleCount: eligibleEmployees.size(),\n            recommendedEmployees: recommendedEmployees*.name,\n            recommendedCount: recommendedEmployees.size(),\n            totalCost: totalCost,\n            expectedBenefit: expectedBenefit,\n            roi: roi\n        ]\n    }\n    \n    def executiveSummary = [\n        totalEmployees: enrichedEmployees.size(),\n        totalPayroll: companyMetrics.totalPayroll,\n        totalCompensation: companyMetrics.totalCompensation,\n        totalBonuses: companyMetrics.totalBonuses,\n        avgSalary: companyMetrics.avgSalary,\n        avgPerformance: companyMetrics.avgPerformance,\n        avgTenure: companyMetrics.avgTenure,\n        departments: departmentGroups.size(),\n        locations: locationGroups.size(),\n        projects: enrichedProjects.size(),\n        activeProjects: activeProjects.size(),\n        completedProjects: completedProjects.size(),\n        highRiskEmployees: highRiskEmployees.size(),\n        criticalRiskEmployees: criticalAttrition.size(),\n        turnoverRiskAmount: totalTurnoverRisk,\n        avgCompensation: companyMetrics.avgCompensation,\n        totalProductivity: companyMetrics.totalProductivity,\n        avgROI: companyMetrics.avgROI,\n        promotionEligible: promotionReadyCandidates.size(),\n        availableResources: availableResources.size(),\n        overallocatedResources: overallocatedResources.size(),\n        totalCertifications: companyMetrics.totalCertifications,\n        processingTime: 0\n    ]\n    \n    masterResults.enrichedEmployeeData = enrichedEmployees\n    masterResults.enrichedProjectData = enrichedProjects\n    masterResults.departmentAnalytics = departmentAnalytics\n    masterResults.locationAnalytics = locationAnalytics\n    masterResults.companyMetrics = companyMetrics\n    masterResults.salaryDistribution = salaryBuckets\n    masterResults.performanceDistribution = performanceBuckets\n    masterResults.tenureDistribution = tenureBuckets\n    masterResults.certificationDistribution = certificationBuckets\n    masterResults.skillAnalysis = skillAnalysis\n    masterResults.compensationTiers = tierDistribution\n    masterResults.retentionRiskAnalysis = retentionRiskAnalysis\n    masterResults.retentionRiskSummary = [\n        critical: criticalRiskEmployees.size(),\n        high: highRiskEmployees.size(),\n        medium: mediumRiskEmployees.size(),\n        low: lowRiskEmployees.size()\n    ]\n    masterResults.projectedAnnualCosts = projectedCosts\n    masterResults.benchmarkComparison = benchmarkAnalysis\n    masterResults.topPerformers = topPerformers\n    masterResults.performanceMetrics = performanceMetrics\n    masterResults.topPerformersByScore = topPerformersByScore\n    masterResults.bottomPerformersByScore = bottomPerformersByScore\n    masterResults.salaryGrowthProjections = salaryGrowthProjections\n    masterResults.departmentComparison = departmentComparison\n    masterResults.skillGapAnalysis = skillGapAnalysis\n    masterResults.costOptimizationOpportunities = costOptimization\n    masterResults.diversityMetrics = diversityMetrics\n    masterResults.attritionAnalysis = attritionAnalysis\n    masterResults.attritionSummary = [\n        critical: criticalAttrition.size(),\n        high: highAttrition.size(),\n        totalRisk: totalAttritionRisk\n    ]\n    masterResults.trainingNeeds = trainingNeeds\n    masterResults.budgetAllocation = budgetAllocation\n    masterResults.competencyMatrix = competencyMatrix\n    masterResults.successorPlanning = successorPlanning\n    masterResults.marketComparison = marketComparison\n    masterResults.quarterlyForecasts = quarterlyForecasts\n    masterResults.yearlyForecasts = yearlyForecasts\n    masterResults.productivityMetrics = productivityMetrics\n    masterResults.teamComposition = teamComposition\n    masterResults.projectAnalytics = projectAnalytics\n    masterResults.resourceAllocation = resourceAllocation\n    masterResults.availableResources = availableResources*.employee\n    masterResults.allocatedResources = allocatedResources*.employee\n    masterResults.overallocatedResources = overallocatedResources*.employee\n    masterResults.careerPathAnalysis = careerPathAnalysis\n    masterResults.promotionReadyCandidates = promotionReadyCandidates*.employee\n    masterResults.compensationEquityAnalysis = compensationEquityAnalysis\n    masterResults.underpaidEmployees = underpaidEmployees*.employee\n    masterResults.overpaidEmployees = overpaidEmployees*.employee\n    masterResults.trainingROIAnalysis = trainingROIAnalysis\n    masterResults.turnoverImpactAnalysis = turnoverImpactAnalysis\n    masterResults.workforceSegmentation = segmentDistribution\n    masterResults.benchmarkComparisons = benchmarkComparisons\n    masterResults.longTermStrategicPlan = longTermStrategicPlan\n    masterResults.trainingProgramAnalysis = trainingProgramAnalysis\n    masterResults.executiveSummary = executiveSummary\n    masterResults.processingTimeMs = System.currentTimeMillis() - pipelineStart\n    masterResults.executiveSummary.processingTime = masterResults.processingTimeMs\n    \n    return masterResults\n}\n\ndef finalOutput = executeComprehensiveEnterpriseDataPipeline()\nreturn [\n    status: 'SUCCESS',\n    timestamp: System.currentTimeMillis(),\n    dataPoints: finalOutput.enrichedEmployeeData.size(),\n    projectCount: finalOutput.enrichedProjectData.size(),\n    totalMetrics: finalOutput.size(),\n    executiveSummary: finalOutput.executiveSummary,\n    departments: finalOutput.departmentAnalytics.keySet(),\n    locations: finalOutput.locationAnalytics.keySet(),\n    processingTime: finalOutput.processingTimeMs\n]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_P59Eh",
			"index":14,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\nimport java.time.temporal.ChronoUnit\ndef executeComprehensiveDataPipeline() {\ndef masterResults = [:]\ndef pipelineStart = System.currentTimeMillis()\ndef employeeData = [[id: 1, name: 'Alice Johnson', dept: 'Engineering', sal: 95000, hire: '2018-03-15', perf: 4.5, skills: ['Java', 'Python', 'SQL'], loc: 'NYC'],\n[id: 2, name: 'Bob Smith', dept: 'Engineering', sal: 110000, hire: '2016-07-22', perf: 4.8, skills: ['Java', 'AWS', 'Kubernetes'], loc: 'SF'],\n[id: 3, name: 'Carol Davis', dept: 'Sales', sal: 75000, hire: '2019-01-10', perf: 4.2, skills: ['CRM', 'Negotiation'], loc: 'NYC'],\n[id: 4, name: 'Dave Wilson', dept: 'Marketing', sal: 68000, hire: '2020-05-18', perf: 3.9, skills: ['SEO', 'Analytics'], loc: 'LA'],\n[id: 5, name: 'Eve Martinez', dept: 'Engineering', sal: 88000, hire: '2019-11-03', perf: 4.3, skills: ['Docker', 'Python', 'CI/CD'], loc: 'NYC'],\n[id: 6, name: 'Frank Brown', dept: 'HR', sal: 72000, hire: '2017-09-12', perf: 4.0, skills: ['Recruitment', 'HRIS'], loc: 'SF'],\n[id: 7, name: 'Grace Lee', dept: 'Finance', sal: 82000, hire: '2018-02-28', perf: 4.6, skills: ['Excel', 'SAP'], loc: 'NYC'],\n[id: 8, name: 'Hank Chen', dept: 'Engineering', sal: 102000, hire: '2017-06-14', perf: 4.7, skills: ['Scala', 'Spark'], loc: 'SF'],\n[id: 9, name: 'Ivy Rodriguez', dept: 'Sales', sal: 78000, hire: '2020-08-20', perf: 4.1, skills: ['B2B', 'Strategy'], loc: 'LA'],\n[id: 10, name: 'Jack Taylor', dept: 'Marketing', sal: 71000, hire: '2019-12-05', perf: 3.8, skills: ['Content'], loc: 'NYC'],\n[id: 11, name: 'Karen White', dept: 'Engineering', sal: 98000, hire: '2018-11-20', perf: 4.4, skills: ['Go', 'Microservices'], loc: 'SF'],\n[id: 12, name: 'Leo Harris', dept: 'Sales', sal: 80000, hire: '2017-03-08', perf: 4.5, skills: ['Enterprise', 'Contracts'], loc: 'NYC'],\n[id: 13, name: 'Mia Clark', dept: 'HR', sal: 69000, hire: '2021-01-15', perf: 3.7, skills: ['Training', 'Benefits'], loc: 'LA'],\n[id: 14, name: 'Nick Lewis', dept: 'Finance', sal: 91000, hire: '2016-08-30', perf: 4.6, skills: ['Accounting', 'Tax'], loc: 'SF'],\n[id: 15, name: 'Olivia Walker', dept: 'Marketing', sal: 73000, hire: '2019-04-12', perf: 4.0, skills: ['Digital', 'Social'], loc: 'NYC']]\ndef projectData = [[id: 'P001', name: 'Cloud Migration', budget: 500000, team: [1, 2, 5, 11], status: 'Active', priority: 'High'],\n[id: 'P002', name: 'CRM Upgrade', budget: 300000, team: [3, 9, 12], status: 'Active', priority: 'Medium'],\n[id: 'P003', name: 'Marketing Campaign', budget: 150000, team: [4, 10, 15], status: 'Planning', priority: 'Low'],\n[id: 'P004', name: 'HR System', budget: 200000, team: [6, 13], status: 'Active', priority: 'Medium'],\n[id: 'P005', name: 'Financial Audit', budget: 250000, team: [7, 14], status: 'Completed', priority: 'High']]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef today = LocalDate.now()\ndef enrichedEmployees = employeeData.collect { emp ->\ndef hireDate = LocalDate.parse(emp.hire, formatter)\ndef daysSinceHire = ChronoUnit.DAYS.between(hireDate, today)\ndef yearsOfService = Period.between(hireDate, today).years\ndef monthsOfService = Period.between(hireDate, today).months\ndef baseBonus = emp.sal * 0.10\ndef performanceBonus = emp.sal * (emp.perf / 5.0) * 0.05\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + performanceBonus + tenureBonus\ndef adjustedSalary = emp.sal * (1 + (yearsOfService * 0.02))\ndef projectedSalary = emp.sal * Math.pow(1.03, 3)\ndef retirementContribution = emp.sal * 0.06\ndef healthBenefits = 12000\ndef totalCompensation = emp.sal + totalBonus + retirementContribution + healthBenefits\ndef skillValue = emp.skills.size() * 5000\ndef performanceMultiplier = emp.perf / 4.0\ndef marketValue = emp.sal * performanceMultiplier\n[id: emp.id, name: emp.name, department: emp.dept, location: emp.loc, baseSalary: emp.sal, adjustedSalary: adjustedSalary,\nprojectedSalary: projectedSalary, hireDate: hireDate, daysSinceHire: daysSinceHire, yearsOfService: yearsOfService,\nmonthsOfService: monthsOfService, skills: emp.skills, skillCount: emp.skills.size(), skillValue: skillValue,\nperformance: emp.perf, performanceMultiplier: performanceMultiplier, marketValue: marketValue, baseBonus: baseBonus,\nperformanceBonus: performanceBonus, tenureBonus: tenureBonus, totalBonus: totalBonus, retirementContribution: retirementContribution,\nhealthBenefits: healthBenefits, totalCompensation: totalCompensation]\n}\ndef departmentGroups = enrichedEmployees.groupBy { it.department }\ndef locationGroups = enrichedEmployees.groupBy { it.location }\ndef performanceTiers = enrichedEmployees.groupBy { emp ->\nif (emp.performance >= 4.5) return 'Excellent'\nelse if (emp.performance >= 4.0) return 'Good'\nelse if (emp.performance >= 3.5) return 'Average'\nelse return 'NeedsImprovement'\n}\ndef departmentAnalytics = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef performances = employees*.performance\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalCompensation = compensations.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgPerformance = performances.sum() / performances.size()\ndef maxPerformance = performances.max()\ndef minPerformance = performances.min()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndef performanceVariance = performances.collect { (it - avgPerformance) ** 2 }.sum() / performances.size()\ndef performanceStdDev = Math.sqrt(performanceVariance)\ndef efficiencyScore = (avgPerformance / (avgSalary / 10000)) * 100\ndef costPerEmployee = totalCompensation / employees.size()\ndef retentionRate = 100 - ((employees.findAll { it.yearsOfService < 1 }.size() / employees.size()) * 100)\ndef promotionEligible = employees.findAll { it.yearsOfService >= 2 && it.performance >= 4.0 }.size()\ndef trainingBudget = totalPayroll * 0.02\ndef recruitmentBudget = totalPayroll * 0.05\ndef totalDeptBudget = totalPayroll + totalBonuses + trainingBudget + recruitmentBudget\ndepartmentAnalytics[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary, maxSalary: maxSalary,\nmedianSalary: medianSalary, salaryRange: salaryRange, stdDeviation: stdDeviation, totalPayroll: totalPayroll,\ntotalCompensation: totalCompensation, totalBonuses: totalBonuses, avgCompensation: avgCompensation,\navgPerformance: avgPerformance, minPerformance: minPerformance, maxPerformance: maxPerformance,\nperformanceStdDev: performanceStdDev, avgTenure: avgTenure, minTenure: minTenure, maxTenure: maxTenure,\nuniqueSkills: uniqueSkills.size(), topSkills: topSkills, skillDiversity: uniqueSkills.size() / employees.size(),\nefficiencyScore: efficiencyScore, costPerEmployee: costPerEmployee, retentionRate: retentionRate,\npromotionEligible: promotionEligible, trainingBudget: trainingBudget, recruitmentBudget: recruitmentBudget,\ntotalBudget: totalDeptBudget]\n}\ndef locationAnalytics = [:]\nlocationGroups.each { loc, employees ->\ndef salaries = employees*.baseSalary\ndef avgSalary = salaries.sum() / salaries.size()\ndef totalPayroll = salaries.sum()\ndef headcount = employees.size()\ndef deptDistribution = employees.groupBy { it.department }.collectEntries { dept, emps -> [(dept): emps.size()] }\ndef avgPerformance = employees*.performance.sum() / employees.size()\ndef avgTenure = employees*.yearsOfService.sum() / employees.size()\ndef skillSet = employees*.skills.flatten().toSet()\ndef costOfLiving = loc == 'SF' ? 1.4 : (loc == 'NYC' ? 1.3 : 1.0)\ndef adjustedCost = totalPayroll * costOfLiving\nlocationAnalytics[loc] = [headcount: headcount, totalPayroll: totalPayroll, avgSalary: avgSalary,\ndepartmentDistribution: deptDistribution, avgPerformance: avgPerformance, avgTenure: avgTenure,\nuniqueSkills: skillSet.size(), costOfLiving: costOfLiving, adjustedCost: adjustedCost]\n}\ndef companyMetrics = [:]\ndef allSalaries = enrichedEmployees*.baseSalary\ndef allCompensations = enrichedEmployees*.totalCompensation\ndef allPerformances = enrichedEmployees*.performance\ndef allTenures = enrichedEmployees*.yearsOfService\ncompanyMetrics.totalEmployees = enrichedEmployees.size()\ncompanyMetrics.totalPayroll = allSalaries.sum()\ncompanyMetrics.totalCompensation = allCompensations.sum()\ncompanyMetrics.totalBonuses = enrichedEmployees*.totalBonus.sum()\ncompanyMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyMetrics.minSalary = allSalaries.min()\ncompanyMetrics.maxSalary = allSalaries.max()\ncompanyMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyMetrics.avgSalary) ** 2 }.sum() / allSalaries.size()\ncompanyMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyMetrics.avgPerformance = allPerformances.sum() / allPerformances.size()\ncompanyMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedEmployees.sort { -it.performance }.take(5)\ndef bottomPerformers = enrichedEmployees.sort { it.performance }.take(3)\ndef highEarners = enrichedEmployees.sort { -it.baseSalary }.take(5)\ndef seniorEmployees = enrichedEmployees.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedEmployees.findAll { it.yearsOfService < 3 }\ndef midLevelEmployees = enrichedEmployees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 5 }\ncompanyMetrics.topPerformers = topPerformers*.name\ncompanyMetrics.highEarners = highEarners*.name\ncompanyMetrics.seniorCount = seniorEmployees.size()\ncompanyMetrics.midLevelCount = midLevelEmployees.size()\ncompanyMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedEmployees.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedEmployees.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedEmployees.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedEmployees.findAll { it.baseSalary >= 100000 }.size()]\ndef performanceBuckets = ['Excellent': enrichedEmployees.findAll { it.performance >= 4.5 }.size(),\n'Good': enrichedEmployees.findAll { it.performance >= 4.0 && it.performance < 4.5 }.size(),\n'Average': enrichedEmployees.findAll { it.performance >= 3.5 && it.performance < 4.0 }.size(),\n'NeedsImprovement': enrichedEmployees.findAll { it.performance < 3.5 }.size()]\ndef tenureBuckets = ['0-2years': enrichedEmployees.findAll { it.yearsOfService < 2 }.size(),\n'2-5years': enrichedEmployees.findAll { it.yearsOfService >= 2 && it.yearsOfService < 5 }.size(),\n'5-10years': enrichedEmployees.findAll { it.yearsOfService >= 5 && it.yearsOfService < 10 }.size(),\n'10+years': enrichedEmployees.findAll { it.yearsOfService >= 10 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedEmployees*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(10)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedEmployees.size()\nskillAnalysis.skillDistribution = skillCounts\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala', 'Go']\ndef techEmployees = enrichedEmployees.findAll { emp -> emp.skills.any { skill -> techSkills.contains(skill) } }\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedEmployees.size()) * 100\nskillAnalysis.avgTechSalary = techEmployees*.baseSalary.sum() / techEmployees.size()\ndef businessSkills = ['CRM', 'Negotiation', 'Strategy', 'B2B', 'Enterprise', 'Contracts']\ndef businessEmployees = enrichedEmployees.findAll { emp -> emp.skills.any { skill -> businessSkills.contains(skill) } }\nskillAnalysis.businessEmployeeCount = businessEmployees.size()\nskillAnalysis.avgBusinessSalary = businessEmployees*.baseSalary.sum() / businessEmployees.size()\ndef compensationTiers = enrichedEmployees.collect { emp ->\ndef tier\nif (emp.totalCompensation < 80000) tier = 'Tier1'\nelse if (emp.totalCompensation < 100000) tier = 'Tier2'\nelse if (emp.totalCompensation < 120000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRiskAnalysis = enrichedEmployees.collect { emp ->\ndef riskScore = 0\nif (emp.baseSalary < companyMetrics.avgSalary * 0.85) riskScore += 30\nif (emp.performance < 4.0) riskScore += 20\nif (emp.yearsOfService < 2) riskScore += 25\nif (emp.totalBonus < companyMetrics.avgSalary * 0.1) riskScore += 15\ndef risk = riskScore > 50 ? 'High' : (riskScore > 30 ? 'Medium' : 'Low')\n[employee: emp.name, department: emp.department, riskScore: riskScore, risk: risk, salary: emp.baseSalary, performance: emp.performance]\n}\ndef highRiskEmployees = retentionRiskAnalysis.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRiskAnalysis.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRiskAnalysis.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef currentBonuses = employees*.totalBonus.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = currentBonuses * 1.02\ndef projectedBenefits = employees.size() * 12000 * 1.05\ndef projectedRetirement = currentPayroll * 0.06 * 1.03\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses + projectedBenefits + projectedRetirement\n[(dept): [currentPayroll: currentPayroll, currentBonuses: currentBonuses, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedBenefits: projectedBenefits, projectedRetirement: projectedRetirement,\nprojectedTotal: projectedTotal, yearOverYearIncrease: projectedTotal - (currentPayroll + currentBonuses)]]\n}\ndef benchmarkAnalysis = enrichedEmployees.collect { emp ->\ndef deptAvg = departmentAnalytics[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\ndef marketComparison = emp.marketValue - emp.baseSalary\n[employee: emp.name, department: emp.department, salary: emp.baseSalary, deptAverage: deptAvg,\nvariancePercent: variance, status: status, marketValue: emp.marketValue, marketGap: marketComparison]\n}\ndef performanceMetrics = enrichedEmployees.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef performanceScore = (emp.performance / companyMetrics.avgPerformance) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore + performanceScore) / 4\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore, skillScore: skillScore,\nperformanceScore: performanceScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(10)\ndef salaryGrowthProjections = enrichedEmployees.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, year1: year1, year2: year2, year3: year3,\nyear4: year4, projectedYear5: year5, totalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentAnalytics.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef performanceIndex = (stats.avgPerformance / companyMetrics.avgPerformance) * 100\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / stats.headcount) * 100)\ndef growthPotential = stats.promotionEligible / stats.headcount * 100\n[department: dept, headcount: stats.headcount, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\navgPerformance: stats.avgPerformance, performanceIndex: performanceIndex, retentionScore: retentionScore,\navgTenure: stats.avgTenure, growthPotential: growthPotential]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\ndef missingBusinessSkills = businessSkills.findAll { !deptSkills.contains(it) }\ndef avgSkillCount = employees*.skillCount.sum() / employees.size()\n[department: dept, currentSkills: deptSkills.size(), avgSkillsPerPerson: avgSkillCount,\nmissingTechSkills: missingTechSkills, missingBusinessSkills: missingBusinessSkills]\n}\ndef costOptimization = enrichedEmployees.findAll { emp ->\nemp.baseSalary > departmentAnalytics[emp.department].avgSalary * 1.15 && emp.performance < 4.0\n}.collect { emp ->\ndef targetSalary = departmentAnalytics[emp.department].avgSalary\ndef potentialSavings = emp.baseSalary - targetSalary\n[employee: emp.name, department: emp.department, currentSalary: emp.baseSalary, targetSalary: targetSalary,\npotentialSavings: potentialSavings, performance: emp.performance]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentAnalytics[dept].salaryRange\ndef performanceSpread = departmentAnalytics[dept].maxPerformance - departmentAnalytics[dept].minPerformance\ndef tenureSpread = departmentAnalytics[dept].maxTenure - departmentAnalytics[dept].minTenure\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread,\nperformanceSpread: performanceSpread, tenureSpread: tenureSpread]\n}\ndef attritionAnalysis = enrichedEmployees.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.performance < 4.0) attritionRisk += 20\nif (emp.skillCount < 2) attritionRisk += 15\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 10\ndef riskLevel = attritionRisk > 60 ? 'Critical' : (attritionRisk > 40 ? 'High' : (attritionRisk > 20 ? 'Medium' : 'Low'))\n[employee: emp.name, department: emp.department, attritionRisk: attritionRisk, riskLevel: riskLevel,\ntenure: emp.yearsOfService, performance: emp.performance]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\ndef lowPerformers = employees.findAll { it.performance < 4.0 }\ndef trainingCandidates = (needsTraining + lowPerformers).unique { it.id }\ndef trainingCost = trainingCandidates.size() * 5000\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: trainingCandidates.size(),\nlowPerformers: lowPerformers.size(), estimatedTrainingCost: trainingCost]\n}\ndef budgetAllocation = departmentAnalytics.collect { dept, stats ->\ndef payroll = stats.totalPayroll\ndef bonuses = stats.totalBonuses\ndef training = stats.trainingBudget\ndef recruitment = stats.recruitmentBudget\ndef benefits = stats.headcount * 12000\ndef retirement = payroll * 0.06\ndef overhead = (payroll + bonuses) * 0.15\ndef total = payroll + bonuses + training + recruitment + benefits + retirement + overhead\n[department: dept, payroll: payroll, bonuses: bonuses, training: training, recruitment: recruitment,\nbenefits: benefits, retirement: retirement, overhead: overhead, total: total]\n}\ndef competencyMatrix = enrichedEmployees.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef performanceScore = emp.performance * 20\ndef compensationLevel = (emp.baseSalary / companyMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + performanceScore + compensationLevel) / 4\ndef grade = overallCompetency >= 80 ? 'A' : (overallCompetency >= 65 ? 'B' : (overallCompetency >= 50 ? 'C' : 'D'))\n[employee: emp.name, technical: technicalScore, experience: experienceScore, performance: performanceScore,\ncompensation: compensationLevel, overall: overallCompetency, grade: grade]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedEmployees.findAll {\nit.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService &&\nit.performance >= 4.0 && it.skillCount >= 2\n}\ndef readySuccessors = potentialSuccessors.findAll { it.yearsOfService >= 5 && it.performance >= 4.5 }\n[seniorEmployee: emp.name, position: emp.department, yearsOfService: emp.yearsOfService,\npotentialSuccessors: potentialSuccessors*.name, readySuccessors: readySuccessors*.name,\nsuccessionRisk: readySuccessors.size() == 0 ? 'High' : (readySuccessors.size() == 1 ? 'Medium' : 'Low')]\n}\ndef marketComparison = enrichedEmployees.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef marketRateWithPerf = emp.marketValue\ndef gap = marketRate - emp.baseSalary\ndef perfGap = marketRateWithPerf - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, department: emp.department, currentSalary: emp.baseSalary, marketRate: marketRate,\nperformanceAdjustedMarket: marketRateWithPerf, gap: gap, performanceGap: perfGap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyMetrics.totalBonuses / 4\ndef quarterBenefits = enrichedEmployees.size() * 3000\ndef quarterRetirement = quarterPayroll * 0.06\ndef quarterTotal = quarterPayroll + quarterBonuses + quarterBenefits + quarterRetirement\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, benefits: quarterBenefits,\nretirement: quarterRetirement, total: quarterTotal]\n}\ndef yearlyForecasts = (1..5).collect { year ->\ndef growthRate = 1 + (0.03 * year * 0.95)\ndef forecastPayroll = companyMetrics.totalPayroll * Math.pow(1.03, year)\ndef forecastBonuses = companyMetrics.totalBonuses * Math.pow(1.02, year)\ndef forecastHeadcount = Math.ceil(enrichedEmployees.size() * Math.pow(1.05, year))\ndef forecastBenefits = forecastHeadcount * 12000 * Math.pow(1.04, year)\ndef forecastTotal = forecastPayroll + forecastBonuses + forecastBenefits\n[year: \"Year$year\", payroll: forecastPayroll, bonuses: forecastBonuses, headcount: forecastHeadcount,\nbenefits: forecastBenefits, total: forecastTotal]\n}\ndef productivityMetrics = enrichedEmployees.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount * emp.performance / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 8 ? 'Excellent' : (outputPerDollar > 5 ? 'Good' : (outputPerDollar > 3 ? 'Average' : 'Poor'))\ndef valueScore = (emp.performance * emp.skillCount * 1000) / emp.baseSalary\n[employee: emp.name, productivity: outputPerDollar, efficiencyRating: efficiencyRating, valueScore: valueScore]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef avgAge = employees*.yearsOfService.sum() / employees.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size(), avgTenure: avgAge]\ndef isBalanced = juniors > 0 && mids > 0 && seniors > 0\n[department: dept, composition: balance, balanced: isBalanced]\n}\ndef enrichedProjects = projectData.collect { proj ->\ndef teamMembers = enrichedEmployees.findAll { emp -> proj.team.contains(emp.id) }\ndef teamSalaries = teamMembers*.baseSalary.sum()\ndef teamPerformance = teamMembers*.performance.sum() / teamMembers.size()\ndef teamSkills = teamMembers*.skills.flatten().toSet()\ndef teamTenure = teamMembers*.yearsOfService.sum() / teamMembers.size()\ndef utilizationRate = (teamMembers.size() / enrichedEmployees.size()) * 100\ndef costPerMonth = teamSalaries / 12\ndef budgetUtilization = (costPerMonth * 6) / proj.budget * 100\n[id: proj.id, name: proj.name, budget: proj.budget, status: proj.status, priority: proj.priority,\nteamSize: teamMembers.size(), teamMembers: teamMembers*.name, teamSalaries: teamSalaries,\navgTeamPerformance: teamPerformance, teamSkills: teamSkills.size(), avgTeamTenure: teamTenure,\nutilizationRate: utilizationRate, monthlyCost: costPerMonth, budgetUtilization: budgetUtilization]\n}\ndef projectAnalytics = [:]\ndef activeProjects = enrichedProjects.findAll { it.status == 'Active' }\ndef completedProjects = enrichedProjects.findAll { it.status == 'Completed' }\ndef planningProjects = enrichedProjects.findAll { it.status == 'Planning' }\nprojectAnalytics.totalProjects = enrichedProjects.size()\nprojectAnalytics.activeProjects = activeProjects.size()\nprojectAnalytics.completedProjects = completedProjects.size()\nprojectAnalytics.planningProjects = planningProjects.size()\nprojectAnalytics.totalBudget = enrichedProjects*.budget.sum()\nprojectAnalytics.activeBudget = activeProjects*.budget.sum()\nprojectAnalytics.avgTeamSize = enrichedProjects*.teamSize.sum() / enrichedProjects.size()\nprojectAnalytics.avgBudget = projectAnalytics.totalBudget / enrichedProjects.size()\ndef projectByPriority = enrichedProjects.groupBy { it.priority }\nprojectAnalytics.highPriorityCount = projectByPriority['High']?.size() ?: 0\nprojectAnalytics.mediumPriorityCount = projectByPriority['Medium']?.size() ?: 0\nprojectAnalytics.lowPriorityCount = projectByPriority['Low']?.size() ?: 0\ndef resourceAllocation = enrichedEmployees.collect { emp ->\ndef assignedProjects = enrichedProjects.findAll { proj -> proj.teamMembers.contains(emp.name) }\ndef projectCount = assignedProjects.size()\ndef totalProjectBudget = assignedProjects*.budget.sum() ?: 0\ndef utilizationScore = projectCount * 25\n[employee: emp.name, department: emp.department, assignedProjects: projectCount, projectNames: assignedProjects*.name,\ntotalBudget: totalProjectBudget, utilizationScore: utilizationScore, status: projectCount > 2 ? 'Overallocated' : (projectCount > 0 ? 'Allocated' : 'Available')]\n}\ndef availableResources = resourceAllocation.findAll { it.status == 'Available' }\ndef overallocatedResources = resourceAllocation.findAll { it.status == 'Overallocated' }\ndef careerPathAnalysis = enrichedEmployees.collect { emp ->\ndef currentLevel = emp.yearsOfService < 3 ? 'Junior' : (emp.yearsOfService < 7 ? 'Mid' : 'Senior')\ndef nextLevel = currentLevel == 'Junior' ? 'Mid' : (currentLevel == 'Mid' ? 'Senior' : 'Principal')\ndef timeToPromotion = currentLevel == 'Junior' ? (3 - emp.yearsOfService) : (currentLevel == 'Mid' ? (7 - emp.yearsOfService) : 0)\ndef promotionReady = emp.performance >= 4.0 && timeToPromotion <= 0\ndef skillGap = currentLevel == 'Junior' ? 1 : (currentLevel == 'Mid' ? 2 : 0)\n[employee: emp.name, currentLevel: currentLevel, nextLevel: nextLevel, yearsOfService: emp.yearsOfService,\ntimeToPromotion: Math.max(0, timeToPromotion), promotionReady: promotionReady, requiredSkills: skillGap,\ncurrentSkills: emp.skillCount, performance: emp.performance]\n}\ndef compensationEquityAnalysis = enrichedEmployees.collect { emp ->\ndef peers = enrichedEmployees.findAll { it.department == emp.department && it.yearsOfService >= emp.yearsOfService - 1 &&\nit.yearsOfService <= emp.yearsOfService + 1 && it.id != emp.id }\ndef avgPeerSalary = peers ? peers*.baseSalary.sum() / peers.size() : emp.baseSalary\ndef equityGap = emp.baseSalary - avgPeerSalary\ndef equityRatio = avgPeerSalary > 0 ? (emp.baseSalary / avgPeerSalary) * 100 : 100\n[employee: emp.name, salary: emp.baseSalary, peerAverage: avgPeerSalary, equityGap: equityGap,\nequityRatio: equityRatio, status: equityRatio < 95 ? 'Underpaid' : (equityRatio > 105 ? 'Overpaid' : 'Fair')]\n}\ndef trainingROIAnalysis = trainingNeeds.collect { dept ->\ndef deptEmployees = departmentGroups[dept.department]\ndef avgSalary = deptEmployees*.baseSalary.sum() / deptEmployees.size()\ndef avgPerformance = deptEmployees*.performance.sum() / deptEmployees.size()\ndef expectedPerformanceGain = 0.2\ndef expectedSalaryImpact = avgSalary * expectedPerformanceGain * 0.1\ndef trainingCost = dept.estimatedTrainingCost\ndef roi = trainingCost > 0 ? ((expectedSalaryImpact * dept.employeesNeedingTraining - trainingCost) / trainingCost) * 100 : 0\n[department: dept.department, trainingCost: trainingCost, candidateCount: dept.employeesNeedingTraining,\nexpectedGain: expectedSalaryImpact, roi: roi, recommendation: roi > 50 ? 'Invest' : (roi > 0 ? 'Consider' : 'Review')]\n}\ndef turnoverImpactAnalysis = retentionRiskAnalysis.collect { risk ->\ndef employee = enrichedEmployees.find { it.name == risk.employee }\ndef replacementCost = employee.baseSalary * 0.5\ndef trainingCost = 15000\ndef productivityLoss = employee.baseSalary * 0.2\ndef totalImpact = replacementCost + trainingCost + productivityLoss\n[employee: risk.employee, riskLevel: risk.risk, salary: risk.salary, replacementCost: replacementCost,\ntrainingCost: trainingCost, productivityLoss: productivityLoss, totalImpact: totalImpact]\n}\ndef highImpactRisks = turnoverImpactAnalysis.findAll { it.riskLevel == 'High' }\ndef totalTurnoverRisk = highImpactRisks*.totalImpact.sum() ?: 0\ndef workforceSegmentation = enrichedEmployees.collect { emp ->\ndef segment\nif (emp.performance >= 4.5 && emp.baseSalary >= companyMetrics.avgSalary * 1.2) segment = 'HighPerformer-HighPay'\nelse if (emp.performance >= 4.5 && emp.baseSalary < companyMetrics.avgSalary) segment = 'HighPerformer-LowPay'\nelse if (emp.performance < 4.0 && emp.baseSalary >= companyMetrics.avgSalary * 1.2) segment = 'LowPerformer-HighPay'\nelse if (emp.performance < 4.0 && emp.baseSalary < companyMetrics.avgSalary) segment = 'LowPerformer-LowPay'\nelse segment = 'Average'\n[employee: emp.name, segment: segment, performance: emp.performance, salary: emp.baseSalary]\n}\ndef segmentDistribution = workforceSegmentation.countBy { it.segment }\ndef benchmarkComparisons = departmentAnalytics.collect { dept, stats ->\ndef industryAvgSalary = stats.avgSalary * 1.05\ndef industryAvgPerformance = 4.2\ndef salaryCompetitiveness = (stats.avgSalary / industryAvgSalary) * 100\ndef performanceCompetitiveness = (stats.avgPerformance / industryAvgPerformance) * 100\n[department: dept, avgSalary: stats.avgSalary, industryAvgSalary: industryAvgSalary,\nsalaryCompetitiveness: salaryCompetitiveness, avgPerformance: stats.avgPerformance,\nindustryAvgPerformance: industryAvgPerformance, performanceCompetitiveness: performanceCompetitiveness]\n}\ndef longTermStrategicPlan = (1..10).collect { year ->\ndef targetHeadcount = Math.ceil(enrichedEmployees.size() * Math.pow(1.08, year))\ndef targetPayroll = companyMetrics.totalPayroll * Math.pow(1.04, year)\ndef targetRevenue = targetPayroll * 3.5\ndef targetProfit = targetRevenue * 0.15\ndef investmentNeeded = targetHeadcount * 50000\n[year: year, targetHeadcount: targetHeadcount, targetPayroll: targetPayroll, targetRevenue: targetRevenue,\ntargetProfit: targetProfit, investmentNeeded: investmentNeeded]\n}\ndef executiveSummary = [\ntotalEmployees: enrichedEmployees.size(),\ntotalPayroll: companyMetrics.totalPayroll,\ntotalCompensation: companyMetrics.totalCompensation,\navgSalary: companyMetrics.avgSalary,\navgPerformance: companyMetrics.avgPerformance,\navgTenure: companyMetrics.avgTenure,\ndepartments: departmentGroups.size(),\nlocations: locationGroups.size(),\nprojects: enrichedProjects.size(),\nactiveProjects: activeProjects.size(),\nhighRiskEmployees: highRiskEmployees.size(),\nturnoverRiskAmount: totalTurnoverRisk,\navgCompensation: companyMetrics.avgCompensation,\nprocessingTime: 0\n]\nmasterResults.enrichedEmployeeData = enrichedEmployees\nmasterResults.enrichedProjectData = enrichedProjects\nmasterResults.departmentAnalytics = departmentAnalytics\nmasterResults.locationAnalytics = locationAnalytics\nmasterResults.companyMetrics = companyMetrics\nmasterResults.salaryDistribution = salaryBuckets\nmasterResults.performanceDistribution = performanceBuckets\nmasterResults.tenureDistribution = tenureBuckets\nmasterResults.skillAnalysis = skillAnalysis\nmasterResults.compensationTiers = tierDistribution\nmasterResults.retentionRiskAnalysis = retentionRiskAnalysis\nmasterResults.retentionRiskSummary = [highRisk: highRiskEmployees.size(), mediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nmasterResults.projectedAnnualCosts = projectedCosts\nmasterResults.benchmarkComparison = benchmarkAnalysis\nmasterResults.topPerformers = topPerformers\nmasterResults.performanceMetrics = performanceMetrics\nmasterResults.topPerformersByScore = topPerformersByScore\nmasterResults.salaryGrowthProjections = salaryGrowthProjections\nmasterResults.departmentComparison = departmentComparison\nmasterResults.skillGapAnalysis = skillGapAnalysis\nmasterResults.costOptimizationOpportunities = costOptimization\nmasterResults.diversityMetrics = diversityMetrics\nmasterResults.attritionAnalysis = attritionAnalysis\nmasterResults.trainingNeeds = trainingNeeds\nmasterResults.budgetAllocation = budgetAllocation\nmasterResults.competencyMatrix = competencyMatrix\nmasterResults.successorPlanning = successorPlanning\nmasterResults.marketComparison = marketComparison\nmasterResults.quarterlyForecasts = quarterlyForecasts\nmasterResults.yearlyForecasts = yearlyForecasts\nmasterResults.productivityMetrics = productivityMetrics\nmasterResults.teamComposition = teamComposition\nmasterResults.projectAnalytics = projectAnalytics\nmasterResults.resourceAllocation = resourceAllocation\nmasterResults.availableResources = availableResources*.employee\nmasterResults.overallocatedResources = overallocatedResources*.employee\nmasterResults.careerPathAnalysis = careerPathAnalysis\nmasterResults.compensationEquityAnalysis = compensationEquityAnalysis\nmasterResults.trainingROIAnalysis = trainingROIAnalysis\nmasterResults.turnoverImpactAnalysis = turnoverImpactAnalysis\nmasterResults.workforceSegmentation = segmentDistribution\nmasterResults.benchmarkComparisons = benchmarkComparisons\nmasterResults.longTermStrategicPlan = longTermStrategicPlan\nmasterResults.executiveSummary = executiveSummary\nmasterResults.processingTimeMs = System.currentTimeMillis() - pipelineStart\nmasterResults.executiveSummary.processingTime = masterResults.processingTimeMs\nreturn masterResults\n}\ndef finalOutput = executeComprehensiveDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalOutput.enrichedEmployeeData.size(),\ntotalMetrics: finalOutput.size(), executiveSummary: finalOutput.executiveSummary, departments: finalOutput.departmentAnalytics.keySet(),\nprojects: finalOutput.enrichedProjectData.size(), processingTime: finalOutput.processingTimeMs]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		}
	],
	"ownerUserId":186875,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":false,
	"tags":[
		
	],
	"version":7
}