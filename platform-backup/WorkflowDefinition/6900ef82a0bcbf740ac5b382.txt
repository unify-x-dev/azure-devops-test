{
	"appsUsed":[
		
	],
	"createdTime":1761668994563,
	"deleted":false,
	"deploymentState":{
		"deployedAt":1761672190176,
		"deployedBy":186875,
		"deployedDefinitionId":"6900fbfd121d195dbbfaa475",
		"status":"DEPLOYED",
		"version":4,
		"workflowVersion":5
	},
	"edges":[
		{
			"fromNodeId":"n_uCnw9",
			"priority":0,
			"skip":false,
			"toNodeId":"n_1KJCW",
			"type":"next"
		},
		{
			"fromNodeId":"n_1KJCW",
			"priority":0,
			"skip":false,
			"toNodeId":"_my5ex",
			"type":"next"
		},
		{
			"fromNodeId":"_my5ex",
			"priority":0,
			"skip":false,
			"toNodeId":"_QZ5pN",
			"type":"next"
		},
		{
			"fromNodeId":"_QZ5pN",
			"priority":0,
			"skip":false,
			"toNodeId":"_PlTO6",
			"type":"next"
		},
		{
			"fromNodeId":"_PlTO6",
			"priority":0,
			"skip":false,
			"toNodeId":"_UJ47G",
			"type":"next"
		},
		{
			"fromNodeId":"_UJ47G",
			"priority":0,
			"skip":false,
			"toNodeId":"_o3KbW",
			"type":"next"
		},
		{
			"fromNodeId":"_o3KbW",
			"priority":0,
			"skip":false,
			"toNodeId":"_HlLmw",
			"type":"next"
		},
		{
			"fromNodeId":"_HlLmw",
			"priority":0,
			"skip":false,
			"toNodeId":"_CzrNP",
			"type":"next"
		},
		{
			"fromNodeId":"_CzrNP",
			"priority":0,
			"skip":false,
			"toNodeId":"_SC8Vw",
			"type":"next"
		},
		{
			"fromNodeId":"_SC8Vw",
			"priority":0,
			"skip":false,
			"toNodeId":"_qz4Ox",
			"type":"next"
		},
		{
			"fromNodeId":"_qz4Ox",
			"priority":0,
			"skip":false,
			"toNodeId":"_7rKyo",
			"type":"next"
		},
		{
			"fromNodeId":"_7rKyo",
			"priority":0,
			"skip":false,
			"toNodeId":"_P59Eh",
			"type":"next"
		}
	],
	"id":"6900ef82a0bcbf740ac5b382",
	"lastModifiedBy":186875,
	"lcName":"testauto2811",
	"modifiedTime":1761672359871,
	"name":"testauto2811",
	"nodes":[
		{
			"context":{
				"appName":"webhooks",
				"resourceVersion":833,
				"resourceName":"webhooks_default"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"n_uCnw9",
			"index":1,
			"inputs":{
				"request":{
					"contentType":"application/json"
				}
			},
			"skip":false,
			"subTitle":"Webhook",
			"title":"New event",
			"trigger":{
				"type":"WEBHOOK"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"n_1KJCW",
			"index":2,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_my5ex",
			"index":3,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_QZ5pN",
			"index":4,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_PlTO6",
			"index":5,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_UJ47G",
			"index":6,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_o3KbW",
			"index":7,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_HlLmw",
			"index":8,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_CzrNP",
			"index":9,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_SC8Vw",
			"index":10,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_qz4Ox",
			"index":11,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_7rKyo",
			"index":12,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\ndef processCompleteDataPipeline() {\ndef results = [:], startTime = System.currentTimeMillis()\ndef rawData = [[id: 1, name: 'Alice', dept: 'Eng', sal: 95000, hire: '2018-03-15', skills: ['Java', 'Python', 'SQL']],\n[id: 2, name: 'Bob', dept: 'Eng', sal: 110000, hire: '2016-07-22', skills: ['Java', 'AWS', 'Kubernetes']],\n[id: 3, name: 'Carol', dept: 'Sales', sal: 75000, hire: '2019-01-10', skills: ['CRM', 'Negotiation']],\n[id: 4, name: 'Dave', dept: 'Marketing', sal: 68000, hire: '2020-05-18', skills: ['SEO', 'Analytics']],\n[id: 5, name: 'Eve', dept: 'Eng', sal: 88000, hire: '2019-11-03', skills: ['Docker', 'Python', 'CI/CD']],\n[id: 6, name: 'Frank', dept: 'HR', sal: 72000, hire: '2017-09-12', skills: ['Recruitment', 'HRIS']],\n[id: 7, name: 'Grace', dept: 'Finance', sal: 82000, hire: '2018-02-28', skills: ['Excel', 'SAP']],\n[id: 8, name: 'Hank', dept: 'Eng', sal: 102000, hire: '2017-06-14', skills: ['Scala', 'Spark']],\n[id: 9, name: 'Ivy', dept: 'Sales', sal: 78000, hire: '2020-08-20', skills: ['B2B', 'Strategy']],\n[id: 10, name: 'Jack', dept: 'Marketing', sal: 71000, hire: '2019-12-05', skills: ['Content']]]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef enrichedData = rawData.collect { record ->\ndef hireDate = LocalDate.parse(record.hire, formatter)\ndef yearsOfService = Period.between(hireDate, LocalDate.now()).years\ndef baseBonus = record.sal * 0.10\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + tenureBonus\ndef adjustedSalary = record.sal * (1 + (yearsOfService * 0.02))\n[id: record.id, name: record.name, department: record.dept, baseSalary: record.sal,\nadjustedSalary: adjustedSalary, hireDate: hireDate, yearsOfService: yearsOfService,\nskills: record.skills, skillCount: record.skills.size(), baseBonus: baseBonus,\ntenureBonus: tenureBonus, totalBonus: totalBonus, totalCompensation: record.sal + totalBonus]\n}\ndef departmentGroups = enrichedData.groupBy { it.department }\ndef departmentStats = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndepartmentStats[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary,\nmaxSalary: maxSalary, medianSalary: medianSalary, salaryRange: salaryRange,\nstdDeviation: stdDeviation, totalPayroll: totalPayroll, totalBonuses: totalBonuses,\navgCompensation: avgCompensation, avgTenure: avgTenure, minTenure: minTenure,\nmaxTenure: maxTenure, uniqueSkills: uniqueSkills.size(), topSkills: topSkills,\nskillDiversity: uniqueSkills.size() / employees.size()]\n}\ndef companyWideMetrics = [:]\ndef allSalaries = enrichedData*.baseSalary\ndef allCompensations = enrichedData*.totalCompensation\ndef allTenures = enrichedData*.yearsOfService\ncompanyWideMetrics.totalEmployees = enrichedData.size()\ncompanyWideMetrics.totalPayroll = allSalaries.sum()\ncompanyWideMetrics.totalBonuses = enrichedData*.totalBonus.sum()\ncompanyWideMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyWideMetrics.minSalary = allSalaries.min()\ncompanyWideMetrics.maxSalary = allSalaries.max()\ncompanyWideMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyWideMetrics.avgSalary) ** 2 }.sum()\nsalaryVariance = salaryVariance / allSalaries.size()\ncompanyWideMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyWideMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyWideMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedData.sort { -it.totalCompensation }.take(3)\ndef bottomPerformers = enrichedData.sort { it.baseSalary }.take(3)\ndef seniorEmployees = enrichedData.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedData.findAll { it.yearsOfService < 3 }\ncompanyWideMetrics.topPerformers = topPerformers*.name\ncompanyWideMetrics.seniorCount = seniorEmployees.size()\ncompanyWideMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedData.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedData.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedData.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedData.findAll { it.baseSalary >= 100000 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedData*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(5)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedData.size()\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala']\ndef techEmployees = enrichedData.findAll { emp ->\nemp.skills.any { skill -> techSkills.contains(skill) }\n}\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedData.size()) * 100\ndef compensationTiers = enrichedData.collect { emp ->\ndef tier\nif (emp.totalCompensation < 70000) tier = 'Tier1'\nelse if (emp.totalCompensation < 90000) tier = 'Tier2'\nelse if (emp.totalCompensation < 110000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRisk = enrichedData.collect { emp ->\ndef risk = 'Low'\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.85) risk = 'High'\nelse if (emp.baseSalary < companyWideMetrics.avgSalary * 0.95) risk = 'Medium'\n[employee: emp.name, department: emp.department, risk: risk, salary: emp.baseSalary]\n}\ndef highRiskEmployees = retentionRisk.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRisk.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRisk.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = employees*.totalBonus.sum() * 1.02\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses\n[(dept): [currentPayroll: currentPayroll, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedTotal: projectedTotal,\nyearOverYearIncrease: projectedTotal - currentPayroll]]\n}\ndef benchmarkAnalysis = enrichedData.collect { emp ->\ndef deptAvg = departmentStats[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\n[employee: emp.name, department: emp.department, salary: emp.baseSalary,\ndeptAverage: deptAvg, variancePercent: variance, status: status]\n}\ndef performanceMetrics = enrichedData.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyWideMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyWideMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore) / 3\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore,\nskillScore: skillScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(5)\ndef salaryGrowthProjections = enrichedData.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, projectedYear5: year5,\ntotalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentStats.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / \ndepartmentGroups[dept].size()) * 100)\n[department: dept, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\nretentionScore: retentionScore, avgTenure: stats.avgTenure]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\n[department: dept, currentSkills: deptSkills.size(), missingTechSkills: missingTechSkills]\n}\ndef costOptimization = enrichedData.findAll { emp ->\nemp.baseSalary > departmentStats[emp.department].avgSalary * 1.15\n}.collect { emp ->\ndef potentialSavings = emp.baseSalary - departmentStats[emp.department].avgSalary\n[employee: emp.name, currentSalary: emp.baseSalary, potentialSavings: potentialSavings]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentStats[dept].salaryRange\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread]\n}\nresults.enrichedEmployeeData = enrichedData\nresults.departmentStatistics = departmentStats\nresults.companyMetrics = companyWideMetrics\nresults.salaryDistribution = salaryBuckets\nresults.skillAnalysis = skillAnalysis\nresults.compensationTiers = tierDistribution\nresults.retentionRiskAssessment = [highRisk: highRiskEmployees.size(),\nmediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nresults.projectedAnnualCosts = projectedCosts\nresults.benchmarkComparison = benchmarkAnalysis\nresults.topPerformers = topPerformers\nresults.performanceMetrics = performanceMetrics\nresults.topPerformersByScore = topPerformersByScore\nresults.salaryGrowthProjections = salaryGrowthProjections\nresults.departmentComparison = departmentComparison\nresults.skillGapAnalysis = skillGapAnalysis\nresults.costOptimizationOpportunities = costOptimization\nresults.diversityMetrics = diversityMetrics\nresults.processingTimeMs = System.currentTimeMillis() - startTime\ndef attritionAnalysis = enrichedData.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyWideMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.skillCount < 2) attritionRisk += 20\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 15\n[employee: emp.name, attritionRisk: attritionRisk, riskLevel: attritionRisk > 50 ? 'High' : (attritionRisk > 30 ? 'Medium' : 'Low')]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: needsTraining.size()]\n}\ndef budgetAllocation = departmentStats.collect { dept, stats ->\ndef trainingBudget = stats.totalPayroll * 0.02\ndef recruitmentBudget = stats.totalPayroll * 0.05\ndef totalBudget = stats.totalPayroll + stats.totalBonuses + trainingBudget + recruitmentBudget\n[department: dept, payroll: stats.totalPayroll, bonuses: stats.totalBonuses, training: trainingBudget, recruitment: recruitmentBudget, total: totalBudget]\n}\ndef competencyMatrix = enrichedData.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef compensationLevel = (emp.baseSalary / companyWideMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + compensationLevel) / 3\n[employee: emp.name, technical: technicalScore, experience: experienceScore, compensation: compensationLevel, overall: overallCompetency]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedData.findAll { it.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService && it.skillCount >= 2 }\n[seniorEmployee: emp.name, position: emp.department, readySuccessors: potentialSuccessors*.name]\n}\ndef marketComparison = enrichedData.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef gap = marketRate - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, currentSalary: emp.baseSalary, marketRate: marketRate, gap: gap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyWideMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyWideMetrics.totalBonuses / 4\ndef quarterTotal = quarterPayroll + quarterBonuses\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, total: quarterTotal]\n}\ndef productivityMetrics = enrichedData.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 5 ? 'Excellent' : (outputPerDollar > 3 ? 'Good' : 'Average')\n[employee: emp.name, productivity: outputPerDollar, rating: efficiencyRating]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size()]\n[department: dept, composition: balance, balanced: juniors > 0 && seniors > 0]\n}\nresults.attritionAnalysis = attritionAnalysis\nresults.trainingNeeds = trainingNeeds\nresults.budgetAllocation = budgetAllocation\nresults.competencyMatrix = competencyMatrix\nresults.successorPlanning = successorPlanning\nresults.marketComparison = marketComparison\nresults.quarterlyForecasts = quarterlyForecasts\nresults.productivityMetrics = productivityMetrics\nresults.teamComposition = teamComposition\nresults.summary = [totalEmployees: enrichedData.size(), totalPayroll: companyWideMetrics.totalPayroll, avgSalary: companyWideMetrics.avgSalary, departments: departmentGroups.size(), processingTime: results.processingTimeMs]\nreturn results\n}\ndef finalResults = processCompleteDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalResults.enrichedEmployeeData.size(), metrics: finalResults.companyMetrics, summary: finalResults.summary]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1033,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_mpvKO-1",
			"id":"_P59Eh",
			"index":13,
			"inputs":{
				"input":{
					"type":"object",
					"additionalProperties":false,
					"properties":{
						"input":{
							"type":"string",
							"title":"input"
						}
					}
				},
				"code":"import java.time.LocalDate\nimport java.time.Period\nimport java.time.format.DateTimeFormatter\nimport java.time.temporal.ChronoUnit\ndef executeComprehensiveDataPipeline() {\ndef masterResults = [:]\ndef pipelineStart = System.currentTimeMillis()\ndef employeeData = [[id: 1, name: 'Alice Johnson', dept: 'Engineering', sal: 95000, hire: '2018-03-15', perf: 4.5, skills: ['Java', 'Python', 'SQL'], loc: 'NYC'],\n[id: 2, name: 'Bob Smith', dept: 'Engineering', sal: 110000, hire: '2016-07-22', perf: 4.8, skills: ['Java', 'AWS', 'Kubernetes'], loc: 'SF'],\n[id: 3, name: 'Carol Davis', dept: 'Sales', sal: 75000, hire: '2019-01-10', perf: 4.2, skills: ['CRM', 'Negotiation'], loc: 'NYC'],\n[id: 4, name: 'Dave Wilson', dept: 'Marketing', sal: 68000, hire: '2020-05-18', perf: 3.9, skills: ['SEO', 'Analytics'], loc: 'LA'],\n[id: 5, name: 'Eve Martinez', dept: 'Engineering', sal: 88000, hire: '2019-11-03', perf: 4.3, skills: ['Docker', 'Python', 'CI/CD'], loc: 'NYC'],\n[id: 6, name: 'Frank Brown', dept: 'HR', sal: 72000, hire: '2017-09-12', perf: 4.0, skills: ['Recruitment', 'HRIS'], loc: 'SF'],\n[id: 7, name: 'Grace Lee', dept: 'Finance', sal: 82000, hire: '2018-02-28', perf: 4.6, skills: ['Excel', 'SAP'], loc: 'NYC'],\n[id: 8, name: 'Hank Chen', dept: 'Engineering', sal: 102000, hire: '2017-06-14', perf: 4.7, skills: ['Scala', 'Spark'], loc: 'SF'],\n[id: 9, name: 'Ivy Rodriguez', dept: 'Sales', sal: 78000, hire: '2020-08-20', perf: 4.1, skills: ['B2B', 'Strategy'], loc: 'LA'],\n[id: 10, name: 'Jack Taylor', dept: 'Marketing', sal: 71000, hire: '2019-12-05', perf: 3.8, skills: ['Content'], loc: 'NYC'],\n[id: 11, name: 'Karen White', dept: 'Engineering', sal: 98000, hire: '2018-11-20', perf: 4.4, skills: ['Go', 'Microservices'], loc: 'SF'],\n[id: 12, name: 'Leo Harris', dept: 'Sales', sal: 80000, hire: '2017-03-08', perf: 4.5, skills: ['Enterprise', 'Contracts'], loc: 'NYC'],\n[id: 13, name: 'Mia Clark', dept: 'HR', sal: 69000, hire: '2021-01-15', perf: 3.7, skills: ['Training', 'Benefits'], loc: 'LA'],\n[id: 14, name: 'Nick Lewis', dept: 'Finance', sal: 91000, hire: '2016-08-30', perf: 4.6, skills: ['Accounting', 'Tax'], loc: 'SF'],\n[id: 15, name: 'Olivia Walker', dept: 'Marketing', sal: 73000, hire: '2019-04-12', perf: 4.0, skills: ['Digital', 'Social'], loc: 'NYC']]\ndef projectData = [[id: 'P001', name: 'Cloud Migration', budget: 500000, team: [1, 2, 5, 11], status: 'Active', priority: 'High'],\n[id: 'P002', name: 'CRM Upgrade', budget: 300000, team: [3, 9, 12], status: 'Active', priority: 'Medium'],\n[id: 'P003', name: 'Marketing Campaign', budget: 150000, team: [4, 10, 15], status: 'Planning', priority: 'Low'],\n[id: 'P004', name: 'HR System', budget: 200000, team: [6, 13], status: 'Active', priority: 'Medium'],\n[id: 'P005', name: 'Financial Audit', budget: 250000, team: [7, 14], status: 'Completed', priority: 'High']]\ndef formatter = DateTimeFormatter.ofPattern('yyyy-MM-dd')\ndef today = LocalDate.now()\ndef enrichedEmployees = employeeData.collect { emp ->\ndef hireDate = LocalDate.parse(emp.hire, formatter)\ndef daysSinceHire = ChronoUnit.DAYS.between(hireDate, today)\ndef yearsOfService = Period.between(hireDate, today).years\ndef monthsOfService = Period.between(hireDate, today).months\ndef baseBonus = emp.sal * 0.10\ndef performanceBonus = emp.sal * (emp.perf / 5.0) * 0.05\ndef tenureBonus = yearsOfService * 500\ndef totalBonus = baseBonus + performanceBonus + tenureBonus\ndef adjustedSalary = emp.sal * (1 + (yearsOfService * 0.02))\ndef projectedSalary = emp.sal * Math.pow(1.03, 3)\ndef retirementContribution = emp.sal * 0.06\ndef healthBenefits = 12000\ndef totalCompensation = emp.sal + totalBonus + retirementContribution + healthBenefits\ndef skillValue = emp.skills.size() * 5000\ndef performanceMultiplier = emp.perf / 4.0\ndef marketValue = emp.sal * performanceMultiplier\n[id: emp.id, name: emp.name, department: emp.dept, location: emp.loc, baseSalary: emp.sal, adjustedSalary: adjustedSalary,\nprojectedSalary: projectedSalary, hireDate: hireDate, daysSinceHire: daysSinceHire, yearsOfService: yearsOfService,\nmonthsOfService: monthsOfService, skills: emp.skills, skillCount: emp.skills.size(), skillValue: skillValue,\nperformance: emp.perf, performanceMultiplier: performanceMultiplier, marketValue: marketValue, baseBonus: baseBonus,\nperformanceBonus: performanceBonus, tenureBonus: tenureBonus, totalBonus: totalBonus, retirementContribution: retirementContribution,\nhealthBenefits: healthBenefits, totalCompensation: totalCompensation]\n}\ndef departmentGroups = enrichedEmployees.groupBy { it.department }\ndef locationGroups = enrichedEmployees.groupBy { it.location }\ndef performanceTiers = enrichedEmployees.groupBy { emp ->\nif (emp.performance >= 4.5) return 'Excellent'\nelse if (emp.performance >= 4.0) return 'Good'\nelse if (emp.performance >= 3.5) return 'Average'\nelse return 'NeedsImprovement'\n}\ndef departmentAnalytics = [:]\ndepartmentGroups.each { dept, employees ->\ndef salaries = employees*.baseSalary\ndef compensations = employees*.totalCompensation\ndef performances = employees*.performance\ndef tenures = employees*.yearsOfService\ndef avgSalary = salaries.sum() / salaries.size()\ndef minSalary = salaries.min()\ndef maxSalary = salaries.max()\ndef salaryRange = maxSalary - minSalary\ndef medianSalary = salaries.sort()[salaries.size().intdiv(2)]\ndef avgCompensation = compensations.sum() / compensations.size()\ndef totalPayroll = salaries.sum()\ndef totalCompensation = compensations.sum()\ndef totalBonuses = employees*.totalBonus.sum()\ndef avgPerformance = performances.sum() / performances.size()\ndef maxPerformance = performances.max()\ndef minPerformance = performances.min()\ndef avgTenure = tenures.sum() / tenures.size()\ndef maxTenure = tenures.max()\ndef minTenure = tenures.min()\ndef allSkills = employees*.skills.flatten()\ndef uniqueSkills = allSkills.toSet()\ndef skillFrequency = allSkills.countBy { it }\ndef topSkills = skillFrequency.sort { -it.value }.take(3)\ndef varianceSum = salaries.collect { (it - avgSalary) ** 2 }.sum()\ndef variance = varianceSum / salaries.size()\ndef stdDeviation = Math.sqrt(variance)\ndef performanceVariance = performances.collect { (it - avgPerformance) ** 2 }.sum() / performances.size()\ndef performanceStdDev = Math.sqrt(performanceVariance)\ndef efficiencyScore = (avgPerformance / (avgSalary / 10000)) * 100\ndef costPerEmployee = totalCompensation / employees.size()\ndef retentionRate = 100 - ((employees.findAll { it.yearsOfService < 1 }.size() / employees.size()) * 100)\ndef promotionEligible = employees.findAll { it.yearsOfService >= 2 && it.performance >= 4.0 }.size()\ndef trainingBudget = totalPayroll * 0.02\ndef recruitmentBudget = totalPayroll * 0.05\ndef totalDeptBudget = totalPayroll + totalBonuses + trainingBudget + recruitmentBudget\ndepartmentAnalytics[dept] = [headcount: employees.size(), avgSalary: avgSalary, minSalary: minSalary, maxSalary: maxSalary,\nmedianSalary: medianSalary, salaryRange: salaryRange, stdDeviation: stdDeviation, totalPayroll: totalPayroll,\ntotalCompensation: totalCompensation, totalBonuses: totalBonuses, avgCompensation: avgCompensation,\navgPerformance: avgPerformance, minPerformance: minPerformance, maxPerformance: maxPerformance,\nperformanceStdDev: performanceStdDev, avgTenure: avgTenure, minTenure: minTenure, maxTenure: maxTenure,\nuniqueSkills: uniqueSkills.size(), topSkills: topSkills, skillDiversity: uniqueSkills.size() / employees.size(),\nefficiencyScore: efficiencyScore, costPerEmployee: costPerEmployee, retentionRate: retentionRate,\npromotionEligible: promotionEligible, trainingBudget: trainingBudget, recruitmentBudget: recruitmentBudget,\ntotalBudget: totalDeptBudget]\n}\ndef locationAnalytics = [:]\nlocationGroups.each { loc, employees ->\ndef salaries = employees*.baseSalary\ndef avgSalary = salaries.sum() / salaries.size()\ndef totalPayroll = salaries.sum()\ndef headcount = employees.size()\ndef deptDistribution = employees.groupBy { it.department }.collectEntries { dept, emps -> [(dept): emps.size()] }\ndef avgPerformance = employees*.performance.sum() / employees.size()\ndef avgTenure = employees*.yearsOfService.sum() / employees.size()\ndef skillSet = employees*.skills.flatten().toSet()\ndef costOfLiving = loc == 'SF' ? 1.4 : (loc == 'NYC' ? 1.3 : 1.0)\ndef adjustedCost = totalPayroll * costOfLiving\nlocationAnalytics[loc] = [headcount: headcount, totalPayroll: totalPayroll, avgSalary: avgSalary,\ndepartmentDistribution: deptDistribution, avgPerformance: avgPerformance, avgTenure: avgTenure,\nuniqueSkills: skillSet.size(), costOfLiving: costOfLiving, adjustedCost: adjustedCost]\n}\ndef companyMetrics = [:]\ndef allSalaries = enrichedEmployees*.baseSalary\ndef allCompensations = enrichedEmployees*.totalCompensation\ndef allPerformances = enrichedEmployees*.performance\ndef allTenures = enrichedEmployees*.yearsOfService\ncompanyMetrics.totalEmployees = enrichedEmployees.size()\ncompanyMetrics.totalPayroll = allSalaries.sum()\ncompanyMetrics.totalCompensation = allCompensations.sum()\ncompanyMetrics.totalBonuses = enrichedEmployees*.totalBonus.sum()\ncompanyMetrics.avgSalary = allSalaries.sum() / allSalaries.size()\ncompanyMetrics.minSalary = allSalaries.min()\ncompanyMetrics.maxSalary = allSalaries.max()\ncompanyMetrics.medianSalary = allSalaries.sort()[allSalaries.size().intdiv(2)]\ndef salaryVariance = allSalaries.collect { (it - companyMetrics.avgSalary) ** 2 }.sum() / allSalaries.size()\ncompanyMetrics.salaryStdDev = Math.sqrt(salaryVariance)\ncompanyMetrics.avgPerformance = allPerformances.sum() / allPerformances.size()\ncompanyMetrics.avgTenure = allTenures.sum() / allTenures.size()\ncompanyMetrics.avgCompensation = allCompensations.sum() / allCompensations.size()\ndef topPerformers = enrichedEmployees.sort { -it.performance }.take(5)\ndef bottomPerformers = enrichedEmployees.sort { it.performance }.take(3)\ndef highEarners = enrichedEmployees.sort { -it.baseSalary }.take(5)\ndef seniorEmployees = enrichedEmployees.findAll { it.yearsOfService >= 5 }\ndef juniorEmployees = enrichedEmployees.findAll { it.yearsOfService < 3 }\ndef midLevelEmployees = enrichedEmployees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 5 }\ncompanyMetrics.topPerformers = topPerformers*.name\ncompanyMetrics.highEarners = highEarners*.name\ncompanyMetrics.seniorCount = seniorEmployees.size()\ncompanyMetrics.midLevelCount = midLevelEmployees.size()\ncompanyMetrics.juniorCount = juniorEmployees.size()\ndef salaryBuckets = ['under60k': enrichedEmployees.findAll { it.baseSalary < 60000 }.size(),\n'60k-80k': enrichedEmployees.findAll { it.baseSalary >= 60000 && it.baseSalary < 80000 }.size(),\n'80k-100k': enrichedEmployees.findAll { it.baseSalary >= 80000 && it.baseSalary < 100000 }.size(),\n'over100k': enrichedEmployees.findAll { it.baseSalary >= 100000 }.size()]\ndef performanceBuckets = ['Excellent': enrichedEmployees.findAll { it.performance >= 4.5 }.size(),\n'Good': enrichedEmployees.findAll { it.performance >= 4.0 && it.performance < 4.5 }.size(),\n'Average': enrichedEmployees.findAll { it.performance >= 3.5 && it.performance < 4.0 }.size(),\n'NeedsImprovement': enrichedEmployees.findAll { it.performance < 3.5 }.size()]\ndef tenureBuckets = ['0-2years': enrichedEmployees.findAll { it.yearsOfService < 2 }.size(),\n'2-5years': enrichedEmployees.findAll { it.yearsOfService >= 2 && it.yearsOfService < 5 }.size(),\n'5-10years': enrichedEmployees.findAll { it.yearsOfService >= 5 && it.yearsOfService < 10 }.size(),\n'10+years': enrichedEmployees.findAll { it.yearsOfService >= 10 }.size()]\ndef skillAnalysis = [:]\ndef allSkillsList = enrichedEmployees*.skills.flatten()\ndef skillCounts = allSkillsList.countBy { it }\nskillAnalysis.totalUniqueSkills = skillCounts.size()\nskillAnalysis.mostCommonSkills = skillCounts.sort { -it.value }.take(10)\nskillAnalysis.avgSkillsPerEmployee = allSkillsList.size() / enrichedEmployees.size()\nskillAnalysis.skillDistribution = skillCounts\ndef techSkills = ['Java', 'Python', 'SQL', 'AWS', 'Kubernetes', 'Docker', 'Spark', 'Scala', 'Go']\ndef techEmployees = enrichedEmployees.findAll { emp -> emp.skills.any { skill -> techSkills.contains(skill) } }\nskillAnalysis.techEmployeeCount = techEmployees.size()\nskillAnalysis.techEmployeePercentage = (techEmployees.size() / enrichedEmployees.size()) * 100\nskillAnalysis.avgTechSalary = techEmployees*.baseSalary.sum() / techEmployees.size()\ndef businessSkills = ['CRM', 'Negotiation', 'Strategy', 'B2B', 'Enterprise', 'Contracts']\ndef businessEmployees = enrichedEmployees.findAll { emp -> emp.skills.any { skill -> businessSkills.contains(skill) } }\nskillAnalysis.businessEmployeeCount = businessEmployees.size()\nskillAnalysis.avgBusinessSalary = businessEmployees*.baseSalary.sum() / businessEmployees.size()\ndef compensationTiers = enrichedEmployees.collect { emp ->\ndef tier\nif (emp.totalCompensation < 80000) tier = 'Tier1'\nelse if (emp.totalCompensation < 100000) tier = 'Tier2'\nelse if (emp.totalCompensation < 120000) tier = 'Tier3'\nelse tier = 'Tier4'\n[employee: emp.name, tier: tier, compensation: emp.totalCompensation]\n}\ndef tierDistribution = compensationTiers.countBy { it.tier }\ndef retentionRiskAnalysis = enrichedEmployees.collect { emp ->\ndef riskScore = 0\nif (emp.baseSalary < companyMetrics.avgSalary * 0.85) riskScore += 30\nif (emp.performance < 4.0) riskScore += 20\nif (emp.yearsOfService < 2) riskScore += 25\nif (emp.totalBonus < companyMetrics.avgSalary * 0.1) riskScore += 15\ndef risk = riskScore > 50 ? 'High' : (riskScore > 30 ? 'Medium' : 'Low')\n[employee: emp.name, department: emp.department, riskScore: riskScore, risk: risk, salary: emp.baseSalary, performance: emp.performance]\n}\ndef highRiskEmployees = retentionRiskAnalysis.findAll { it.risk == 'High' }\ndef mediumRiskEmployees = retentionRiskAnalysis.findAll { it.risk == 'Medium' }\ndef lowRiskEmployees = retentionRiskAnalysis.findAll { it.risk == 'Low' }\ndef projectedCosts = departmentGroups.collectEntries { dept, employees ->\ndef currentPayroll = employees*.baseSalary.sum()\ndef currentBonuses = employees*.totalBonus.sum()\ndef projectedRaises = currentPayroll * 0.03\ndef projectedBonuses = currentBonuses * 1.02\ndef projectedBenefits = employees.size() * 12000 * 1.05\ndef projectedRetirement = currentPayroll * 0.06 * 1.03\ndef projectedTotal = currentPayroll + projectedRaises + projectedBonuses + projectedBenefits + projectedRetirement\n[(dept): [currentPayroll: currentPayroll, currentBonuses: currentBonuses, projectedRaises: projectedRaises,\nprojectedBonuses: projectedBonuses, projectedBenefits: projectedBenefits, projectedRetirement: projectedRetirement,\nprojectedTotal: projectedTotal, yearOverYearIncrease: projectedTotal - (currentPayroll + currentBonuses)]]\n}\ndef benchmarkAnalysis = enrichedEmployees.collect { emp ->\ndef deptAvg = departmentAnalytics[emp.department].avgSalary\ndef variance = ((emp.baseSalary - deptAvg) / deptAvg) * 100\ndef status = variance > 10 ? 'Above' : (variance < -10 ? 'Below' : 'OnPar')\ndef marketComparison = emp.marketValue - emp.baseSalary\n[employee: emp.name, department: emp.department, salary: emp.baseSalary, deptAverage: deptAvg,\nvariancePercent: variance, status: status, marketValue: emp.marketValue, marketGap: marketComparison]\n}\ndef performanceMetrics = enrichedEmployees.collect { emp ->\ndef efficiencyScore = (emp.totalCompensation / companyMetrics.avgCompensation) * 100\ndef tenureScore = (emp.yearsOfService / companyMetrics.avgTenure) * 100\ndef skillScore = (emp.skillCount / skillAnalysis.avgSkillsPerEmployee) * 100\ndef performanceScore = (emp.performance / companyMetrics.avgPerformance) * 100\ndef overallScore = (efficiencyScore + tenureScore + skillScore + performanceScore) / 4\n[employee: emp.name, efficiencyScore: efficiencyScore, tenureScore: tenureScore, skillScore: skillScore,\nperformanceScore: performanceScore, overallScore: overallScore]\n}\ndef topPerformersByScore = performanceMetrics.sort { -it.overallScore }.take(10)\ndef salaryGrowthProjections = enrichedEmployees.collect { emp ->\ndef year1 = emp.baseSalary * 1.03\ndef year2 = year1 * 1.035\ndef year3 = year2 * 1.04\ndef year4 = year3 * 1.04\ndef year5 = year4 * 1.045\ndef totalGrowth = year5 - emp.baseSalary\ndef growthPercentage = (totalGrowth / emp.baseSalary) * 100\n[employee: emp.name, currentSalary: emp.baseSalary, year1: year1, year2: year2, year3: year3,\nyear4: year4, projectedYear5: year5, totalGrowth: totalGrowth, growthPercentage: growthPercentage]\n}\ndef departmentComparison = departmentAnalytics.collect { dept, stats ->\ndef efficiencyRatio = stats.totalPayroll / stats.headcount\ndef bonusRatio = stats.totalBonuses / stats.totalPayroll\ndef performanceIndex = (stats.avgPerformance / companyMetrics.avgPerformance) * 100\ndef retentionScore = 100 - ((highRiskEmployees.findAll { it.department == dept }.size() / stats.headcount) * 100)\ndef growthPotential = stats.promotionEligible / stats.headcount * 100\n[department: dept, headcount: stats.headcount, efficiencyRatio: efficiencyRatio, bonusRatio: bonusRatio,\navgPerformance: stats.avgPerformance, performanceIndex: performanceIndex, retentionScore: retentionScore,\navgTenure: stats.avgTenure, growthPotential: growthPotential]\n}\ndef skillGapAnalysis = departmentGroups.collect { dept, employees ->\ndef deptSkills = employees*.skills.flatten().toSet()\ndef missingTechSkills = techSkills.findAll { !deptSkills.contains(it) }\ndef missingBusinessSkills = businessSkills.findAll { !deptSkills.contains(it) }\ndef avgSkillCount = employees*.skillCount.sum() / employees.size()\n[department: dept, currentSkills: deptSkills.size(), avgSkillsPerPerson: avgSkillCount,\nmissingTechSkills: missingTechSkills, missingBusinessSkills: missingBusinessSkills]\n}\ndef costOptimization = enrichedEmployees.findAll { emp ->\nemp.baseSalary > departmentAnalytics[emp.department].avgSalary * 1.15 && emp.performance < 4.0\n}.collect { emp ->\ndef targetSalary = departmentAnalytics[emp.department].avgSalary\ndef potentialSavings = emp.baseSalary - targetSalary\n[employee: emp.name, department: emp.department, currentSalary: emp.baseSalary, targetSalary: targetSalary,\npotentialSavings: potentialSavings, performance: emp.performance]\n}\ndef diversityMetrics = departmentGroups.collect { dept, employees ->\ndef skillDiversity = employees*.skills.flatten().toSet().size()\ndef salarySpread = departmentAnalytics[dept].salaryRange\ndef performanceSpread = departmentAnalytics[dept].maxPerformance - departmentAnalytics[dept].minPerformance\ndef tenureSpread = departmentAnalytics[dept].maxTenure - departmentAnalytics[dept].minTenure\n[department: dept, skillDiversity: skillDiversity, salarySpread: salarySpread,\nperformanceSpread: performanceSpread, tenureSpread: tenureSpread]\n}\ndef attritionAnalysis = enrichedEmployees.collect { emp ->\ndef attritionRisk = 0\nif (emp.yearsOfService < 2) attritionRisk += 30\nif (emp.baseSalary < companyMetrics.avgSalary * 0.9) attritionRisk += 25\nif (emp.performance < 4.0) attritionRisk += 20\nif (emp.skillCount < 2) attritionRisk += 15\nif (emp.department == 'Sales' || emp.department == 'Marketing') attritionRisk += 10\ndef riskLevel = attritionRisk > 60 ? 'Critical' : (attritionRisk > 40 ? 'High' : (attritionRisk > 20 ? 'Medium' : 'Low'))\n[employee: emp.name, department: emp.department, attritionRisk: attritionRisk, riskLevel: riskLevel,\ntenure: emp.yearsOfService, performance: emp.performance]\n}\ndef trainingNeeds = departmentGroups.collect { dept, employees ->\ndef avgSkills = employees*.skillCount.sum() / employees.size()\ndef needsTraining = employees.findAll { it.skillCount < avgSkills }\ndef lowPerformers = employees.findAll { it.performance < 4.0 }\ndef trainingCandidates = (needsTraining + lowPerformers).unique { it.id }\ndef trainingCost = trainingCandidates.size() * 5000\n[department: dept, avgSkillCount: avgSkills, employeesNeedingTraining: trainingCandidates.size(),\nlowPerformers: lowPerformers.size(), estimatedTrainingCost: trainingCost]\n}\ndef budgetAllocation = departmentAnalytics.collect { dept, stats ->\ndef payroll = stats.totalPayroll\ndef bonuses = stats.totalBonuses\ndef training = stats.trainingBudget\ndef recruitment = stats.recruitmentBudget\ndef benefits = stats.headcount * 12000\ndef retirement = payroll * 0.06\ndef overhead = (payroll + bonuses) * 0.15\ndef total = payroll + bonuses + training + recruitment + benefits + retirement + overhead\n[department: dept, payroll: payroll, bonuses: bonuses, training: training, recruitment: recruitment,\nbenefits: benefits, retirement: retirement, overhead: overhead, total: total]\n}\ndef competencyMatrix = enrichedEmployees.collect { emp ->\ndef technicalScore = emp.skillCount * 20\ndef experienceScore = emp.yearsOfService * 10\ndef performanceScore = emp.performance * 20\ndef compensationLevel = (emp.baseSalary / companyMetrics.maxSalary) * 100\ndef overallCompetency = (technicalScore + experienceScore + performanceScore + compensationLevel) / 4\ndef grade = overallCompetency >= 80 ? 'A' : (overallCompetency >= 65 ? 'B' : (overallCompetency >= 50 ? 'C' : 'D'))\n[employee: emp.name, technical: technicalScore, experience: experienceScore, performance: performanceScore,\ncompensation: compensationLevel, overall: overallCompetency, grade: grade]\n}\ndef successorPlanning = seniorEmployees.collect { emp ->\ndef potentialSuccessors = enrichedEmployees.findAll {\nit.department == emp.department && it.yearsOfService >= 3 && it.yearsOfService < emp.yearsOfService &&\nit.performance >= 4.0 && it.skillCount >= 2\n}\ndef readySuccessors = potentialSuccessors.findAll { it.yearsOfService >= 5 && it.performance >= 4.5 }\n[seniorEmployee: emp.name, position: emp.department, yearsOfService: emp.yearsOfService,\npotentialSuccessors: potentialSuccessors*.name, readySuccessors: readySuccessors*.name,\nsuccessionRisk: readySuccessors.size() == 0 ? 'High' : (readySuccessors.size() == 1 ? 'Medium' : 'Low')]\n}\ndef marketComparison = enrichedEmployees.collect { emp ->\ndef marketRate = emp.baseSalary * 1.15\ndef marketRateWithPerf = emp.marketValue\ndef gap = marketRate - emp.baseSalary\ndef perfGap = marketRateWithPerf - emp.baseSalary\ndef competitive = gap < emp.baseSalary * 0.1\n[employee: emp.name, department: emp.department, currentSalary: emp.baseSalary, marketRate: marketRate,\nperformanceAdjustedMarket: marketRateWithPerf, gap: gap, performanceGap: perfGap, competitive: competitive]\n}\ndef quarterlyForecasts = (1..4).collect { quarter ->\ndef quarterPayroll = companyMetrics.totalPayroll * (1 + (quarter * 0.01))\ndef quarterBonuses = companyMetrics.totalBonuses / 4\ndef quarterBenefits = enrichedEmployees.size() * 3000\ndef quarterRetirement = quarterPayroll * 0.06\ndef quarterTotal = quarterPayroll + quarterBonuses + quarterBenefits + quarterRetirement\n[quarter: \"Q$quarter\", payroll: quarterPayroll, bonuses: quarterBonuses, benefits: quarterBenefits,\nretirement: quarterRetirement, total: quarterTotal]\n}\ndef yearlyForecasts = (1..5).collect { year ->\ndef growthRate = 1 + (0.03 * year * 0.95)\ndef forecastPayroll = companyMetrics.totalPayroll * Math.pow(1.03, year)\ndef forecastBonuses = companyMetrics.totalBonuses * Math.pow(1.02, year)\ndef forecastHeadcount = Math.ceil(enrichedEmployees.size() * Math.pow(1.05, year))\ndef forecastBenefits = forecastHeadcount * 12000 * Math.pow(1.04, year)\ndef forecastTotal = forecastPayroll + forecastBonuses + forecastBenefits\n[year: \"Year$year\", payroll: forecastPayroll, bonuses: forecastBonuses, headcount: forecastHeadcount,\nbenefits: forecastBenefits, total: forecastTotal]\n}\ndef productivityMetrics = enrichedEmployees.collect { emp ->\ndef outputPerDollar = emp.yearsOfService * emp.skillCount * emp.performance / (emp.baseSalary / 10000)\ndef efficiencyRating = outputPerDollar > 8 ? 'Excellent' : (outputPerDollar > 5 ? 'Good' : (outputPerDollar > 3 ? 'Average' : 'Poor'))\ndef valueScore = (emp.performance * emp.skillCount * 1000) / emp.baseSalary\n[employee: emp.name, productivity: outputPerDollar, efficiencyRating: efficiencyRating, valueScore: valueScore]\n}\ndef teamComposition = departmentGroups.collect { dept, employees ->\ndef juniors = employees.findAll { it.yearsOfService < 3 }.size()\ndef mids = employees.findAll { it.yearsOfService >= 3 && it.yearsOfService < 7 }.size()\ndef seniors = employees.findAll { it.yearsOfService >= 7 }.size()\ndef avgAge = employees*.yearsOfService.sum() / employees.size()\ndef balance = [juniors: juniors, mids: mids, seniors: seniors, total: employees.size(), avgTenure: avgAge]\ndef isBalanced = juniors > 0 && mids > 0 && seniors > 0\n[department: dept, composition: balance, balanced: isBalanced]\n}\ndef enrichedProjects = projectData.collect { proj ->\ndef teamMembers = enrichedEmployees.findAll { emp -> proj.team.contains(emp.id) }\ndef teamSalaries = teamMembers*.baseSalary.sum()\ndef teamPerformance = teamMembers*.performance.sum() / teamMembers.size()\ndef teamSkills = teamMembers*.skills.flatten().toSet()\ndef teamTenure = teamMembers*.yearsOfService.sum() / teamMembers.size()\ndef utilizationRate = (teamMembers.size() / enrichedEmployees.size()) * 100\ndef costPerMonth = teamSalaries / 12\ndef budgetUtilization = (costPerMonth * 6) / proj.budget * 100\n[id: proj.id, name: proj.name, budget: proj.budget, status: proj.status, priority: proj.priority,\nteamSize: teamMembers.size(), teamMembers: teamMembers*.name, teamSalaries: teamSalaries,\navgTeamPerformance: teamPerformance, teamSkills: teamSkills.size(), avgTeamTenure: teamTenure,\nutilizationRate: utilizationRate, monthlyCost: costPerMonth, budgetUtilization: budgetUtilization]\n}\ndef projectAnalytics = [:]\ndef activeProjects = enrichedProjects.findAll { it.status == 'Active' }\ndef completedProjects = enrichedProjects.findAll { it.status == 'Completed' }\ndef planningProjects = enrichedProjects.findAll { it.status == 'Planning' }\nprojectAnalytics.totalProjects = enrichedProjects.size()\nprojectAnalytics.activeProjects = activeProjects.size()\nprojectAnalytics.completedProjects = completedProjects.size()\nprojectAnalytics.planningProjects = planningProjects.size()\nprojectAnalytics.totalBudget = enrichedProjects*.budget.sum()\nprojectAnalytics.activeBudget = activeProjects*.budget.sum()\nprojectAnalytics.avgTeamSize = enrichedProjects*.teamSize.sum() / enrichedProjects.size()\nprojectAnalytics.avgBudget = projectAnalytics.totalBudget / enrichedProjects.size()\ndef projectByPriority = enrichedProjects.groupBy { it.priority }\nprojectAnalytics.highPriorityCount = projectByPriority['High']?.size() ?: 0\nprojectAnalytics.mediumPriorityCount = projectByPriority['Medium']?.size() ?: 0\nprojectAnalytics.lowPriorityCount = projectByPriority['Low']?.size() ?: 0\ndef resourceAllocation = enrichedEmployees.collect { emp ->\ndef assignedProjects = enrichedProjects.findAll { proj -> proj.teamMembers.contains(emp.name) }\ndef projectCount = assignedProjects.size()\ndef totalProjectBudget = assignedProjects*.budget.sum() ?: 0\ndef utilizationScore = projectCount * 25\n[employee: emp.name, department: emp.department, assignedProjects: projectCount, projectNames: assignedProjects*.name,\ntotalBudget: totalProjectBudget, utilizationScore: utilizationScore, status: projectCount > 2 ? 'Overallocated' : (projectCount > 0 ? 'Allocated' : 'Available')]\n}\ndef availableResources = resourceAllocation.findAll { it.status == 'Available' }\ndef overallocatedResources = resourceAllocation.findAll { it.status == 'Overallocated' }\ndef careerPathAnalysis = enrichedEmployees.collect { emp ->\ndef currentLevel = emp.yearsOfService < 3 ? 'Junior' : (emp.yearsOfService < 7 ? 'Mid' : 'Senior')\ndef nextLevel = currentLevel == 'Junior' ? 'Mid' : (currentLevel == 'Mid' ? 'Senior' : 'Principal')\ndef timeToPromotion = currentLevel == 'Junior' ? (3 - emp.yearsOfService) : (currentLevel == 'Mid' ? (7 - emp.yearsOfService) : 0)\ndef promotionReady = emp.performance >= 4.0 && timeToPromotion <= 0\ndef skillGap = currentLevel == 'Junior' ? 1 : (currentLevel == 'Mid' ? 2 : 0)\n[employee: emp.name, currentLevel: currentLevel, nextLevel: nextLevel, yearsOfService: emp.yearsOfService,\ntimeToPromotion: Math.max(0, timeToPromotion), promotionReady: promotionReady, requiredSkills: skillGap,\ncurrentSkills: emp.skillCount, performance: emp.performance]\n}\ndef compensationEquityAnalysis = enrichedEmployees.collect { emp ->\ndef peers = enrichedEmployees.findAll { it.department == emp.department && it.yearsOfService >= emp.yearsOfService - 1 &&\nit.yearsOfService <= emp.yearsOfService + 1 && it.id != emp.id }\ndef avgPeerSalary = peers ? peers*.baseSalary.sum() / peers.size() : emp.baseSalary\ndef equityGap = emp.baseSalary - avgPeerSalary\ndef equityRatio = avgPeerSalary > 0 ? (emp.baseSalary / avgPeerSalary) * 100 : 100\n[employee: emp.name, salary: emp.baseSalary, peerAverage: avgPeerSalary, equityGap: equityGap,\nequityRatio: equityRatio, status: equityRatio < 95 ? 'Underpaid' : (equityRatio > 105 ? 'Overpaid' : 'Fair')]\n}\ndef trainingROIAnalysis = trainingNeeds.collect { dept ->\ndef deptEmployees = departmentGroups[dept.department]\ndef avgSalary = deptEmployees*.baseSalary.sum() / deptEmployees.size()\ndef avgPerformance = deptEmployees*.performance.sum() / deptEmployees.size()\ndef expectedPerformanceGain = 0.2\ndef expectedSalaryImpact = avgSalary * expectedPerformanceGain * 0.1\ndef trainingCost = dept.estimatedTrainingCost\ndef roi = trainingCost > 0 ? ((expectedSalaryImpact * dept.employeesNeedingTraining - trainingCost) / trainingCost) * 100 : 0\n[department: dept.department, trainingCost: trainingCost, candidateCount: dept.employeesNeedingTraining,\nexpectedGain: expectedSalaryImpact, roi: roi, recommendation: roi > 50 ? 'Invest' : (roi > 0 ? 'Consider' : 'Review')]\n}\ndef turnoverImpactAnalysis = retentionRiskAnalysis.collect { risk ->\ndef employee = enrichedEmployees.find { it.name == risk.employee }\ndef replacementCost = employee.baseSalary * 0.5\ndef trainingCost = 15000\ndef productivityLoss = employee.baseSalary * 0.2\ndef totalImpact = replacementCost + trainingCost + productivityLoss\n[employee: risk.employee, riskLevel: risk.risk, salary: risk.salary, replacementCost: replacementCost,\ntrainingCost: trainingCost, productivityLoss: productivityLoss, totalImpact: totalImpact]\n}\ndef highImpactRisks = turnoverImpactAnalysis.findAll { it.riskLevel == 'High' }\ndef totalTurnoverRisk = highImpactRisks*.totalImpact.sum() ?: 0\ndef workforceSegmentation = enrichedEmployees.collect { emp ->\ndef segment\nif (emp.performance >= 4.5 && emp.baseSalary >= companyMetrics.avgSalary * 1.2) segment = 'HighPerformer-HighPay'\nelse if (emp.performance >= 4.5 && emp.baseSalary < companyMetrics.avgSalary) segment = 'HighPerformer-LowPay'\nelse if (emp.performance < 4.0 && emp.baseSalary >= companyMetrics.avgSalary * 1.2) segment = 'LowPerformer-HighPay'\nelse if (emp.performance < 4.0 && emp.baseSalary < companyMetrics.avgSalary) segment = 'LowPerformer-LowPay'\nelse segment = 'Average'\n[employee: emp.name, segment: segment, performance: emp.performance, salary: emp.baseSalary]\n}\ndef segmentDistribution = workforceSegmentation.countBy { it.segment }\ndef benchmarkComparisons = departmentAnalytics.collect { dept, stats ->\ndef industryAvgSalary = stats.avgSalary * 1.05\ndef industryAvgPerformance = 4.2\ndef salaryCompetitiveness = (stats.avgSalary / industryAvgSalary) * 100\ndef performanceCompetitiveness = (stats.avgPerformance / industryAvgPerformance) * 100\n[department: dept, avgSalary: stats.avgSalary, industryAvgSalary: industryAvgSalary,\nsalaryCompetitiveness: salaryCompetitiveness, avgPerformance: stats.avgPerformance,\nindustryAvgPerformance: industryAvgPerformance, performanceCompetitiveness: performanceCompetitiveness]\n}\ndef longTermStrategicPlan = (1..10).collect { year ->\ndef targetHeadcount = Math.ceil(enrichedEmployees.size() * Math.pow(1.08, year))\ndef targetPayroll = companyMetrics.totalPayroll * Math.pow(1.04, year)\ndef targetRevenue = targetPayroll * 3.5\ndef targetProfit = targetRevenue * 0.15\ndef investmentNeeded = targetHeadcount * 50000\n[year: year, targetHeadcount: targetHeadcount, targetPayroll: targetPayroll, targetRevenue: targetRevenue,\ntargetProfit: targetProfit, investmentNeeded: investmentNeeded]\n}\ndef executiveSummary = [\ntotalEmployees: enrichedEmployees.size(),\ntotalPayroll: companyMetrics.totalPayroll,\ntotalCompensation: companyMetrics.totalCompensation,\navgSalary: companyMetrics.avgSalary,\navgPerformance: companyMetrics.avgPerformance,\navgTenure: companyMetrics.avgTenure,\ndepartments: departmentGroups.size(),\nlocations: locationGroups.size(),\nprojects: enrichedProjects.size(),\nactiveProjects: activeProjects.size(),\nhighRiskEmployees: highRiskEmployees.size(),\nturnoverRiskAmount: totalTurnoverRisk,\navgCompensation: companyMetrics.avgCompensation,\nprocessingTime: 0\n]\nmasterResults.enrichedEmployeeData = enrichedEmployees\nmasterResults.enrichedProjectData = enrichedProjects\nmasterResults.departmentAnalytics = departmentAnalytics\nmasterResults.locationAnalytics = locationAnalytics\nmasterResults.companyMetrics = companyMetrics\nmasterResults.salaryDistribution = salaryBuckets\nmasterResults.performanceDistribution = performanceBuckets\nmasterResults.tenureDistribution = tenureBuckets\nmasterResults.skillAnalysis = skillAnalysis\nmasterResults.compensationTiers = tierDistribution\nmasterResults.retentionRiskAnalysis = retentionRiskAnalysis\nmasterResults.retentionRiskSummary = [highRisk: highRiskEmployees.size(), mediumRisk: mediumRiskEmployees.size(), lowRisk: lowRiskEmployees.size()]\nmasterResults.projectedAnnualCosts = projectedCosts\nmasterResults.benchmarkComparison = benchmarkAnalysis\nmasterResults.topPerformers = topPerformers\nmasterResults.performanceMetrics = performanceMetrics\nmasterResults.topPerformersByScore = topPerformersByScore\nmasterResults.salaryGrowthProjections = salaryGrowthProjections\nmasterResults.departmentComparison = departmentComparison\nmasterResults.skillGapAnalysis = skillGapAnalysis\nmasterResults.costOptimizationOpportunities = costOptimization\nmasterResults.diversityMetrics = diversityMetrics\nmasterResults.attritionAnalysis = attritionAnalysis\nmasterResults.trainingNeeds = trainingNeeds\nmasterResults.budgetAllocation = budgetAllocation\nmasterResults.competencyMatrix = competencyMatrix\nmasterResults.successorPlanning = successorPlanning\nmasterResults.marketComparison = marketComparison\nmasterResults.quarterlyForecasts = quarterlyForecasts\nmasterResults.yearlyForecasts = yearlyForecasts\nmasterResults.productivityMetrics = productivityMetrics\nmasterResults.teamComposition = teamComposition\nmasterResults.projectAnalytics = projectAnalytics\nmasterResults.resourceAllocation = resourceAllocation\nmasterResults.availableResources = availableResources*.employee\nmasterResults.overallocatedResources = overallocatedResources*.employee\nmasterResults.careerPathAnalysis = careerPathAnalysis\nmasterResults.compensationEquityAnalysis = compensationEquityAnalysis\nmasterResults.trainingROIAnalysis = trainingROIAnalysis\nmasterResults.turnoverImpactAnalysis = turnoverImpactAnalysis\nmasterResults.workforceSegmentation = segmentDistribution\nmasterResults.benchmarkComparisons = benchmarkComparisons\nmasterResults.longTermStrategicPlan = longTermStrategicPlan\nmasterResults.executiveSummary = executiveSummary\nmasterResults.processingTimeMs = System.currentTimeMillis() - pipelineStart\nmasterResults.executiveSummary.processingTime = masterResults.processingTimeMs\nreturn masterResults\n}\ndef finalOutput = executeComprehensiveDataPipeline()\nreturn [status: 'SUCCESS', timestamp: System.currentTimeMillis(), dataPoints: finalOutput.enrichedEmployeeData.size(),\ntotalMetrics: finalOutput.size(), executiveSummary: finalOutput.executiveSummary, departments: finalOutput.departmentAnalytics.keySet(),\nprojects: finalOutput.enrichedProjectData.size(), processingTime: finalOutput.processingTimeMs]",
				"compile_static":false,
				"captureStdOutput":false,
				"parameters":{
					"input":"1"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		}
	],
	"ownerUserId":186875,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":false,
	"tags":[
		
	],
	"version":6
}