{
	"appsUsed":[
		
	],
	"createdTime":1747641655377,
	"deleted":false,
	"deploymentState":{
		"deployedAt":1760296313990,
		"deployedBy":-1,
		"deployedDefinitionId":"68ebfd79672fcc41fb70f4f8",
		"status":"DEPLOYED",
		"version":53,
		"workflowVersion":88
	},
	"edges":[
		{
			"fromNodeId":"KILGA",
			"priority":0,
			"skip":false,
			"toNodeId":"LEozf",
			"type":"next"
		},
		{
			"fromNodeId":"LEozf",
			"priority":0,
			"skip":false,
			"toNodeId":"BVrX3",
			"type":"next"
		}
	],
	"grants":{
		"configs":[
			{
				"permissions":[
					"V"
				],
				"principalType":"GLOBAL"
			}
		]
	},
	"id":"681b2187b8b7345a42b444e8",
	"lastModifiedBy":0,
	"lcName":"text to workflow v2 | graph to adjacency list",
	"modifiedTime":1761722867347,
	"name":"Text to Workflow v2 | Graph to Adjacency List",
	"nodes":[
		{
			"context":{
				"appName":"callables",
				"resourceName":"callables_from_automation"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kOh0v-1",
			"id":"KILGA",
			"index":0,
			"inputs":{
				"result":{
					"type":"object",
					"properties":{
						"workflowAdjList":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"workflowAdjList"
						}
					},
					"additionalProperties":false,
					"required":[],
					"dynamic":true
				},
				"setup":{
					"type":"object",
					"properties":{
						"workflowJson":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"workflowJson"
						},
						"caseId":{
							"type":"string",
							"title":"Case Id"
						}
					},
					"additionalProperties":false,
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Trigger via automation",
			"trigger":{
				"type":"CALLABLE"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":318,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kOh0v-1",
			"id":"LEozf",
			"index":0,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"workflowAdjList":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"workflowAdjList"
						}
					},
					"additionalProperties":false,
					"required":[
						"workflowAdjList"
					]
				},
				"input":{
					"type":"object",
					"properties":{
						"workflowJson":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"workflowJson"
						}
					},
					"additionalProperties":false,
					"required":[
						"workflowJson"
					]
				},
				"compile_static":false,
				"code":"/**\n * Convert a workflow graph (nodes + edges) into an adjacency-list that\n * also labels special edges for IF-ELSE, LOOP and BRANCH blocks.\n */\ndef convertWorkflowToSimpleStructure(workflowJson) {\n\n    /* -----------------------------------------------------------\n       1.  Helper maps\n       ----------------------------------------------------------- */\n    // id ➜ full node (so we can read type / groupId quickly)\n    def nodeById = workflowJson.nodes?.\n            collectEntries { [(it.id): it] } ?: [:]\n\n    /* -----------------------------------------------------------\n       2.  Edge-type classification\n       ----------------------------------------------------------- */\n    def classifyEdge\n    classifyEdge = { edge ->\n        def custom = [\n            loop     : 'next_inside_loop',\n            loopback : 'loopback_to_loop_start',\n            default  : 'next_in_default_branch'\n        ]\n\n        def fromNode = nodeById[edge.fromNodeId]\n        def toNode   = nodeById[edge.toNodeId]\n\n        /* IF-ELSE YES / NO  ----------------------------------- */\n        if (edge?.name in ['yes', 'no'] && fromNode?.type == 'IF_ELSE') {\n            boolean childInsideBranch =\n                    (toNode?.groupId ?: '').startsWith(\"${fromNode.id}\")\n            if (childInsideBranch) {\n                return edge.name == 'yes'\n                        ? 'next_if_condition_match'\n                        : 'next_if_not_condition_match'\n            }\n            // jump that leaves the IF-ELSE block\n            return 'next_after_condition_end'\n        }\n\n        /* LOOP / LOOPBACK  ------------------------------------ */\n        if (edge?.name == 'loopback') {\n            return custom.loopback\n        }\n        if (edge?.type == 'loop') {\n            return custom.loop\n        }\n\n        /* BRANCH (1 / 2 / default …) -------------------------- */\n        if (edge?.type == 'branch') {\n            if (edge.name?.isInteger()) {\n                return \"next_in_branch_number${edge.name}\"\n            }\n            if (edge.name == 'default') {\n                def fromGrp = (fromNode?.groupId ?: '')\n                def toGrp   = (toNode  ?.groupId ?: '')\n                boolean exitsBranch = !toGrp.startsWith(\"${fromNode.id}@\") &&\n                                    toGrp == fromGrp      // ← converging node\n                return exitsBranch ? 'next_after_branch_end'\n                                : custom.default         // original behaviour\n            }\n        }\n\n        /* Any other non-“next” edge with an alias ------------- */\n        if (edge?.type && edge.type != 'next' && custom[edge.type]) {\n            return custom[edge.type]\n        }\n\n        /* fall-back ------------------------------------------- */\n        return edge?.type ?: 'next'\n    }\n\n    /* -----------------------------------------------------------\n       3.  Build next-map from the original edge list\n       ----------------------------------------------------------- */\n    def nextNodes = [:].withDefault { [] }\n\n    workflowJson.edges?.each { edge ->\n        def eType = classifyEdge(edge)\n        nextNodes[edge.fromNodeId] << [node_id: edge.toNodeId,\n                                       edge_type: eType.toString()]\n    }\n\n    /*\n        BRANCH post-processing, removing outgoing edges from every tail node\n         and ensuring there is an edge of type 'next_after_branch_end' from branch\n         root to converging node. Recconecting is handled in conversion\n        back to graph\n    */\n    def branchTailNodes   = [] as Set\n    def convergeCandidate = [:].withDefault { [] as Set }\n\n    workflowJson.nodes?.findAll { it.type == 'BRANCH' }?.each { branchRoot ->\n\n        def rootId    = branchRoot.id              // e.g. n_4fdb4\n        def rootGroup = branchRoot.groupId ?: ''   // e.g. _KKQqz-1\n        def inBranch  = { String grp -> grp?.startsWith(\"${rootId}@\") }\n\n        workflowJson.edges?.each { e ->\n            def fromGrp = nodeById[e.fromNodeId]?.groupId\n            def toGrp   = nodeById[e.toNodeId  ]?.groupId\n\n            /* edge that *leaves* the branch back to the parent group */\n            if (inBranch(fromGrp) && toGrp == rootGroup) {\n                /* delete *only* this single leaving edge */\n                nextNodes[e.fromNodeId].removeAll { it.node_id == e.toNodeId }\n\n                /* treat the node as a true branch-tail\n                        only when nothing is left */\n                if (!nextNodes[e.fromNodeId]) {\n                    branchTailNodes << e.fromNodeId\n                }\n                /* keep original converge-candidate code */\n                convergeCandidate[rootId] << e.toNodeId\n            }\n\n        }\n\n        /*   add root ➜ converging-node if exactly one target found */\n        if (convergeCandidate[rootId].size() == 1) {\n            def tgt = convergeCandidate[rootId].first()\n            boolean alreadyThere = nextNodes[rootId]\n                .any { it.node_id == tgt &&\n                    it.edge_type == 'next_after_branch_end' }\n\n            if (!alreadyThere) {\n                nextNodes[rootId] << [ node_id  : tgt,\n                                    edge_type: 'next_after_branch_end' ]\n            }\n        }\n    }\n\n\n    /* -----------------------------------------------------------\n       4.  Add “next_after_condition_end” links for IF-ELSE roots\n       ----------------------------------------------------------- */\n    workflowJson.nodes?.findAll { it.type == 'IF_ELSE' }?.each { ifNode ->\n        def rootId    = ifNode.id\n        def rootGroup = ifNode.groupId ?: ''\n\n        // An edge that starts inside a branch  (groupId startsWith rootId@)\n        // and lands back in the parent group  (groupId == rootGroup)\n        def exitNodes = [] as Set\n        workflowJson.edges?.each { edge ->\n            def fromGrp = nodeById[edge.fromNodeId]?.groupId\n            def toGrp   = nodeById[edge.toNodeId]?.groupId\n            if (fromGrp?.startsWith(\"${rootId}@\") && toGrp == rootGroup) {\n                exitNodes << edge.toNodeId\n            }\n        }\n\n        // Create the synthetic edges (avoid duplicates)\n        exitNodes.each { tgt ->\n            if (!nextNodes[rootId]\n                    .any { it.node_id == tgt &&\n                           it.edge_type == 'next_after_condition_end' }) {\n                nextNodes[rootId] << [node_id: tgt,\n                                      edge_type: 'next_after_condition_end']\n            }\n        }\n    }\n\n    /* -----------------------------------------------------------\n       5.  LOOP post-processing: turn “next” ➜ “next_after_loop_end”\n       ----------------------------------------------------------- */\n    workflowJson.nodes?.findAll { it.type == 'LOOP' }?.each { loopNode ->\n        nextNodes[loopNode.id]?.each { edge ->\n            if (edge.edge_type == 'next') {\n                edge.edge_type = 'next_after_loop_end'\n            }\n        }\n    }\n\n    /* -----------------------------------------------------------\n       6.  Produce the final simplified structure\n       ----------------------------------------------------------- */\n    def simplified = workflowJson.nodes?.collect { n ->\n        def ctx = n.context ?: [:]\n        def nodeName = ctx.appName ?: 'placeholder'\n        def actionName\n\n        // stop and branch nodes expect action_name = node_name in subsequent steps.\n        if (nodeName == 'stop' || nodeName == 'branch') {\n            actionName = nodeName\n        } else {\n            actionName = ctx.resourceName ?: 'placeholder'\n        }\n\n        def nodeMap = [\n            node_id    : n.id,\n            node_name  : nodeName,\n            action_name: actionName,\n            next       : nextNodes[n.id] ?: []\n        ]\n\n        if (n.containsKey('trigger')) {\n            nodeMap.triggerNode = true\n            if (nodeMap.node_name == 'placeholder') {\n                nodeMap.node_name = 'triggerToUpdate'\n                nodeMap.action_name = 'triggerAction'\n            }\n        }\n\n        return nodeMap\n    } ?: []\n\n\n    return [nodes: simplified]\n}\n\nresult = [ workflowAdjList : convertWorkflowToSimpleStructure( workflowJson ) ]\n",
				"parameters":{
					"workflowJson":"{{ KILGA.outputs.workflowJson  }}"
				}
			},
			"skip":false,
			"subTitle":"graph to adj list",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"callables",
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kOh0v-1",
			"id":"BVrX3",
			"index":0,
			"inputs":{
				"result":{
					"workflowAdjList":"{{ LEozf.outputs.result.workflowAdjList }}"
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		}
	],
	"ownerUserId":39717,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":true,
	"tags":[
		"Text_to_Workflow_v2"
	],
	"version":90
}