{
	"appsUsed":[
		
	],
	"createdTime":1761314647426,
	"deleted":false,
	"edges":[
		{
			"fromNodeId":"n_ls0UY",
			"priority":0,
			"skip":false,
			"toNodeId":"n_7Xo2H",
			"type":"next"
		}
	],
	"id":"68fb875700ea623ea74f75e0",
	"lastModifiedBy":557,
	"lcName":"ytest",
	"modifiedTime":1761381308796,
	"name":"ytest",
	"nodes":[
		{
			"context":{
				"appName":"schedule",
				"resourceVersion":836,
				"resourceName":"schedule_default"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_vz5IJ-1",
			"id":"n_ls0UY",
			"index":1,
			"inputs":{
				"cron":"INTERVAL",
				"sequential":false,
				"interval":15,
				"frequency":"MINUTES"
			},
			"skip":false,
			"subTitle":"Schedule",
			"title":"New recurring event",
			"trigger":{
				"type":"SCHEDULED"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":1023,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_vz5IJ-1",
			"id":"n_7Xo2H",
			"index":2,
			"inputs":{
				"code":"// --- Get input from binding ---\ndef inputRoot = this.binding.variables\ndef list1 = inputRoot.list1 ?: []                      // approver's accessible employees\ndef batchEmpDetailsexcel = inputRoot.batchEmpDetailsexcel ?: []  // Excel input\ndef batchEmpDetailstable = inputRoot.batchEmpDetailstable ?: []  // Table input\ndef defaultRatingList = inputRoot.defaultRatingList ?: []        // Default rating rules\ndef editableList = inputRoot.editableList ?: []\ndef count = (inputRoot.count ?: 0) as Integer\n\n// --- Build approver access set ---\ndef empIdSet = list1.collect { it._pr_xxxern_employeenumber?.toString()?.trim() }.findAll { it }.toSet()\ndef editableSet = editableList.collect { it?.toString()?.trim()?.toLowerCase() }\n                             .findAll { it }.toSet()\n\n// --- Helper functions ---\ndef getRatingNumber = { val ->\n    if (!val) return null\n    try {\n        def numPart = val.toString().split(\"-\")[0]\n        numPart.toInteger()\n    } catch (Exception e) { null }\n}\n\ndef parseIntSafe = { val ->\n    try {\n        if (!val) return 0\n        if (val instanceof Number) return val.toInteger()\n        def digits = val.toString().replaceAll(\"[^0-9]\", \"\")\n        return digits ? digits.toInteger() : 0\n    } catch (Exception e) { 0 }\n}\n\n// --- Step 1: Merge Excel + Table data by EMPID ---\ndef batchEmpDetails = batchEmpDetailsexcel.collect { excelRec ->\n    def empId = excelRec.EMPID?.toString()?.trim()\n    def tableRec = batchEmpDetailstable.find { it.EMPID?.toString()?.trim() == empId } ?: [:]\n\n    return [\n        EMPID: empId,\n        Rating: excelRec.Rating,\n        PreviousRating: tableRec.PreviousRating,\n        Comment1: excelRec.Comment1,\n        Comment2: tableRec.Comment2,\n        ApproverJobLevel: tableRec.ApproverJobLevel,\n        _pr_xxxern_joblevel: tableRec._pr_xxxern_joblevel,\n        ReasonForDefaultRating: tableRec.ReasonForDefaultRating,\n        ApproverRoleName: excelRec.ApproverRoleName ?: tableRec.ApproverRoleName,\n        stage_level_tech: tableRec.stage_level_tech\n    ]\n}\n\n// --- Step 2: Run validations ---\ndef results = []\n\nbatchEmpDetails.each { record ->\n\n    def empId = record.EMPID?.toString()?.trim()\n    def ratingValue = record.Rating?.toString()?.trim()\n    def prevRatingValue = record.PreviousRating?.toString()?.trim()\n    def comment1 = record.Comment1?.toString()?.trim()\n    def comment2 = record.Comment2?.toString()?.trim()\n    def approverJobLevel = record.ApproverJobLevel\n    def empJobLevel = record._pr_xxxern_joblevel\n    def reasonForDefaultRating = record.ReasonForDefaultRating?.toString()?.trim()\n    def approverRoleName = record.ApproverRoleName?.toString()?.trim()\n    def stageLevelTechRaw = record.stage_level_tech\n    def stageLevelTechNorm = stageLevelTechRaw?.toString()?.trim()?.toLowerCase() ?: \"\"\n\n    def rating = getRatingNumber(ratingValue)\n    def prevRating = getRatingNumber(prevRatingValue)\n    def empLevel = parseIntSafe(empJobLevel)\n    def apprLevel = parseIntSafe(approverJobLevel)\n\n    def failureReasons = []\n    def status = true\n\n    // --- :zero: Mandatory field check ---\n    if (!ratingValue) {\n         failureReasons << \"Final rating is missing\"\n         status = false\n    }\n    if ((!comment1 || comment1 == \"\") && (comment2 && comment2 != \"\")) { \n         failureReasons << \"Comment is missing\"\n         status = false\n    }\n    if (status == false) {\n        results << [\n        EMPID: empId,\n        Rating: rating,\n        PreviousRating: prevRatingValue,\n        EmployeeJobLevel: empLevel,\n        ApproverJobLevel: apprLevel,\n        Comment1: comment1,\n        Comment2: comment2,\n        status: status,\n        failure_reasons: failureReasons.join(\" | \")\n    ]\n    return\n    }\n\n    // --- :one: Access check ---\n    def validEmp = empId && empIdSet.contains(empId)\n    if (!validEmp) failureReasons << \"Approver does not have access to edit rating for the following employee\"\n\n    // --- :two: Job level check (only if count == 0) ---\n    if (count == 0) {\n        if (apprLevel <= 0 || empLevel <= 0)\n            failureReasons << \"Invalid job level data\"\n        else if (apprLevel <= empLevel)\n            failureReasons << \"Approver job level must be greater than employee job level to update rating\"\n    }\n\n    // --- :three: Rating & Comment Validation ---\n    def ratingChanged = (rating && !prevRating) || (!rating && prevRating) || (rating != null && prevRating != null && rating != prevRating)\n    def commentChanged = (\n        (comment1 && comment2 && comment1 != comment2) ||\n        (comment1 && !comment2) ||\n        (!comment1 && comment2)\n    )\n\n    if (!ratingChanged) {\n        if (commentChanged) {\n            failureReasons << \"Only comments updated, rating unchanged\"\n            status = true\n        } else {\n            results << [\n                EMPID: empId,\n                Rating: rating,\n                PreviousRating: prevRatingValue,\n                EmployeeJobLevel: empLevel,\n                ApproverJobLevel: apprLevel,\n                Comment1: comment1,\n                Comment2: comment2,\n                status: \"Rejected\",\n                failure_reasons: \"\"\n            ]\n            return\n        }\n    }\n\n    if (!stageLevelTechNorm) {\n        failureReasons << \"You are not allowed to change the ratings for this employee.\"\n        status = false\n    } else if (!editableSet.contains(stageLevelTechNorm)) {\n        failureReasons << \"You are not allowed to change the ratings for this employeeee.\"\n        status = false\n    }\n\n    if (ratingChanged && !commentChanged)\n        failureReasons << \"Comments are unchanged for changed rating\"\n\n    // --- :four: Default Rating Logic ---\n    if (reasonForDefaultRating) {\n        def matchedRule = defaultRatingList.find { \n            it.reason?.toString()?.trim()?.equalsIgnoreCase(reasonForDefaultRating) \n        }\n\n        if (!matchedRule) {\n            failureReasons << \"Invalid reason for default rating (${reasonForDefaultRating})\"\n            status = false\n        } else {\n            def editable = matchedRule.editable?.toString()?.toLowerCase() == \"yes\"\n            def allowedRatings = (matchedRule.allowedRatings instanceof List) ? \n                matchedRule.allowedRatings.collect { it.toString().trim() } : []\n            def rolePlayersAllowed = (matchedRule.rolePlayersAllowed instanceof List) ? \n                matchedRule.rolePlayersAllowed.collect { it.toString().trim() } : []\n            def ratingStr = rating?.toString()\n\n            if (editable) {\n                if (!allowedRatings.contains(ratingStr)) {\n                    failureReasons << \"Given Rating not within allowed ratings of (${reasonForDefaultRating})\"\n                    status = false\n                }\n            } else {\n                if (!rolePlayersAllowed.contains(approverRoleName)) {\n                    failureReasons << \"Approver (${approverRoleName}) not allowed for this default reason (${reasonForDefaultRating})\"\n                    status = false\n                } else if (!allowedRatings.contains(ratingStr)) {\n                    failureReasons << \"Given Rating not within allowed ratings of (${reasonForDefaultRating})\"\n                    status = false\n                }\n            }\n        }\n    }\n\n    if (!failureReasons.isEmpty() && failureReasons.every { !it.startsWith(\"Only comments updated\") }) status = false\n\n    results << [\n        EMPID: empId,\n        Rating: rating,\n        PreviousRating: prevRatingValue,\n        EmployeeJobLevel: empLevel,\n        ApproverJobLevel: apprLevel,\n        Comment1: comment1,\n        Comment2: comment2,\n        status: status,\n        failure_reasons: failureReasons.join(\" | \")\n    ]\n}\n\n// --- Step 3: Separate passed & failed results ---\ndef passed = results.findAll { it.status == true }\ndef failed = results.findAll { it.status == false }\n// --- Step 4: Return with counts ---\nreturn [\n    passed_count: passed.size(),\n    failed_count: failed.size(),\n    passed_results: passed,\n    failed_results: failed\n]",
				"compile_static":false,
				"captureStdOutput":false
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		}
	],
	"ownerUserId":557,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":false,
	"tags":[
		
	],
	"version":11
}