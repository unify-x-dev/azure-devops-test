{
	"appsUsed":[
		
	],
	"createdTime":1761637821357,
	"deleted":false,
	"deploymentState":{
		"deployedAt":1761645564390,
		"deployedBy":39714,
		"deployedDefinitionId":"690093fc5520d463972c0914",
		"status":"DEPLOYED",
		"version":1,
		"workflowVersion":2
	},
	"edges":[
		{
			"fromNodeId":"n_WmBtH",
			"priority":0,
			"skip":false,
			"toNodeId":"n_rh0oF",
			"type":"next"
		},
		{
			"fromNodeId":"n_rh0oF",
			"priority":0,
			"skip":false,
			"toNodeId":"n_nXgwV",
			"type":"next"
		}
	],
	"id":"690075bdad1c2c4565e5de44",
	"lastModifiedBy":45518,
	"lcName":"[virtu-empowerattendancefn]->getconfirmlophttptrigger",
	"modifiedTime":1761812617946,
	"name":"[virtu-emPowerAttendanceFN]->GetCOnfirmLOPHttpTrigger",
	"nodes":[
		{
			"context":{
				"appName":"callables",
				"resourceVersion":965,
				"resourceName":"callables_from_api"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_otcPG-1",
			"id":"n_WmBtH",
			"index":1,
			"inputs":{
				"request":{
					"headers":{
						"type":"object",
						"additionalProperties":false,
						"required":[],
						"properties":{
							"Authorization":{
								"type":"string",
								"title":"Authorization"
							}
						}
					},
					"contentType":"application/json"
				},
				"endpointType":"REST",
				"response":[
					{
						"status":200,
						"contentType":"application/json",
						"textBody":{
							"type":"string"
						}
					}
				],
				"streamingResponse":false
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Trigger via API",
			"trigger":{
				"type":"CALLABLE"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":224,
				"resourceName":"code_by_unifyapps_csharp",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_otcPG-1",
			"id":"n_rh0oF",
			"index":2,
			"inputs":{
				"code":"using System;\nusing System.IO;\nusing System.Threading.Tasks;\nusing System.Text.Json;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Text;\n// --- Base Models ---\npublic class Reportee\n{\n    public long personID { get; set; }\n    public long personNumber { get; set; }\n    public string firstName { get; set; }\n    public string lastName { get; set; }\n    public string middleNames { get; set; }\n    public string displayName { get; set; }\n    public string fullName { get; set; }\n    public string title { get; set; }\n    public EmailAddress[] emailAddresses { get; set; }\n    public string managerType { get; set; }\n    public DateTime effectiveStartDate { get; set; }\n    public DateTime effectiveEndDate { get; set; }\n    public string userName\n    {\n        get\n        {\n            var email = this?.emailAddresses?.Where(x => x.emailType == \"W1\").FirstOrDefault()?.emailAddress;\n            if (email != null)\n            {\n                return email.Split('@')[0];\n            }\n            return string.Empty;\n        }\n    }\n    public string employeeNumber => this.personNumber.ToString();\n}\npublic class EmailAddress\n{\n    public long emailAddressID { get; set; }\n    public long personID { get; set; }\n    public string emailAddress { get; set; }\n    public DateTime dateFrom { get; set; }\n    public DateTime? dateTo { get; set; }\n    public string emailType { get; set; }\n}\n// --- Logic Classes ---\npublic class AuthService\n{\n    private static readonly HttpClient httpClient = new HttpClient();\n    private const string AttendanceSummaryApiBaseUrl = \"https://api.yourcompany.com\";\n    private const string WorkerOcpKey = \"your-ocp-key\";\n    public bool IsUserEqualsToTokenUser(string userName, string authorizationHeader)\n    {\n        var empUserName = GetUserFromToken(authorizationHeader);\n        if (!string.IsNullOrEmpty(empUserName) && empUserName.Split('@')[0].ToLower() == userName.ToLower())\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    public async Task<bool> IsUserReportsToTokenUser(string userName, string personNumber, string authorizationHeader)\n    {\n        var empNumber = await GetEmployeeNumber(authorizationHeader);\n        if (string.IsNullOrEmpty(empNumber))\n        {\n            return false;\n        }\n        string apiUrl = $\"{AttendanceSummaryApiBaseUrl}/emplyoees-api/v1/employees/{empNumber}/reportees\";\n        httpClient.DefaultRequestHeaders.Clear();\n        httpClient.DefaultRequestHeaders.Add(\"Authorization\", authorizationHeader);\n        httpClient.DefaultRequestHeaders.Add(\"Ocp-Apim-Subscription-Key\", WorkerOcpKey);\n        HttpResponseMessage response = await httpClient.GetAsync(apiUrl);\n        if (response.IsSuccessStatusCode)\n        {\n            var responseContent = await response.Content.ReadAsStringAsync();\n            var reportees = JsonSerializer.Deserialize<List<Reportee>>(responseContent, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });\n            var mappedData = reportees?\n                .Where(obj => obj.managerType == \"LINE_MANAGER\" && obj.emailAddresses?.Any(itm => itm.emailType == \"W1\") == true)\n                .Select(obj => new\n                {\n                    personNumber = obj.employeeNumber,\n                    lineManager = obj.managerType,\n                    emailAddress = obj.emailAddresses?.FirstOrDefault(itm => itm.emailType == \"W1\")?.emailAddress\n                }).ToArray();\n            bool userExists = mappedData.Any(item =>\n                item.personNumber == personNumber || \n                (item?.emailAddress?.Split('@')[0].ToLower() == userName.ToLower())\n            );\n            return userExists;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    private string GetUserFromToken(string authorizationHeader)\n    {\n        if (string.IsNullOrEmpty(authorizationHeader) || !authorizationHeader.StartsWith(\"Bearer \"))\n        {\n            return null;\n        }\n        string token = authorizationHeader.Substring(\"Bearer \".Length);\n        try\n        {\n            // Simple token parsing - extract email from token format\n            // In a real scenario, you would use proper JWT validation\n            if (token.Contains(\"@\"))\n            {\n                return token; // Simplified - assuming token contains email\n            }\n            \n            // Fallback: extract from common JWT claim positions\n            var tokenParts = token.Split('.');\n            if (tokenParts.Length >= 2)\n            {\n                // This is a simplified approach - in production use proper JWT library\n                return \"user@company.com\"; // Placeholder\n            }\n            \n            return null;\n        }\n        catch (Exception)\n        {\n            return null;\n        }\n    }\n    public async Task<string> GetEmployeeNumber(string authorizationHeader)\n    {\n        var userEmail = GetUserFromToken(authorizationHeader);\n        if (string.IsNullOrEmpty(userEmail))\n        {\n            return null;\n        }\n        string apiUrl = $\"{AttendanceSummaryApiBaseUrl}/v5-workers-api/v1/workers?onlyData=true&limit=400&q=(UPPER(emails.EmailAddress)='{userEmail.ToUpper()}' and emails.EmailType='W1')\";\n        httpClient.DefaultRequestHeaders.Clear();\n        httpClient.DefaultRequestHeaders.Add(\"Authorization\", authorizationHeader);\n        httpClient.DefaultRequestHeaders.Add(\"Ocp-Apim-Subscription-Key\", WorkerOcpKey);\n        httpClient.DefaultRequestHeaders.Add(\"Accept\", \"application/json\");\n        httpClient.DefaultRequestHeaders.Add(\"REST-Framework-Version\", \"4\");\n        HttpResponseMessage response = await httpClient.GetAsync(apiUrl);\n        var responseContent = await response.Content.ReadAsStringAsync();\n        if (response.IsSuccessStatusCode)\n        {\n            using (JsonDocument document = JsonDocument.Parse(responseContent))\n            {\n                JsonElement root = document.RootElement;\n                if (root.TryGetProperty(\"items\", out JsonElement items) && items.ValueKind == JsonValueKind.Array && items.GetArrayLength() > 0)\n                {\n                    var firstItem = items.EnumerateArray().First();\n                    if (firstItem.TryGetProperty(\"PersonNumber\", out JsonElement personNumber))\n                    {\n                        return personNumber.GetString();\n                    }\n                }\n            }\n        }\n        return null;\n    }\n}\npublic class ConfirmLOPService\n{\n    private readonly AuthService _authService;\n    public ConfirmLOPService(AuthService authService)\n    {\n        _authService = authService;\n    }\n    public async Task<IDictionary<string, object>> GetEmployeeConfirmLOPData(string userName, string startDate, string endDate, string authorizationHeader)\n    {\n        var httpClient = new HttpClient();\n        // Note: The actual API URL and token logic would need to be implemented based on your specific LOP API\n        // This is a placeholder structure following the same pattern\n        string apiUrl = $\"https://api.yourcompany.com/lop-api/v1/records?$filter=xxx_name eq '{userName}' and (xxx_lopdate ge {startDate} and xxx_lopdate le {endDate})\";\n        // Note: Token retrieval would need to be implemented based on your specific authentication\n        string apiToken = await GetToken();\n        httpClient.DefaultRequestHeaders.Clear();\n        httpClient.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {apiToken}\");\n        httpClient.DefaultRequestHeaders.Add(\"Ocp-Apim-Subscription-Key\", \"your-lop-ocp-key\");\n        httpClient.DefaultRequestHeaders.Add(\"Accept\", \"application/json\");\n        HttpResponseMessage response = await httpClient.GetAsync(apiUrl);\n        if (response.IsSuccessStatusCode)\n        {\n            var responseContent = await response.Content.ReadAsStringAsync();\n            \n            // Note: The actual response parsing would depend on your LOP API response structure\n            // This returns the raw response body as the structure is unknown\n            return new Dictionary<string, object> {\n                { \"statusCode\", 200 },\n                { \"body\", new { \n                    message = \"Successfully retrieved LOP data\",\n                    data = responseContent,\n                    rawResponse = true\n                }}\n            };\n        }\n        else\n        {\n            return new Dictionary<string, object> {\n                { \"statusCode\", (int)response.StatusCode },\n                { \"body\", new { message = $\"LOP API call failed with status code: {response.StatusCode}\" } }\n            };\n        }\n    }\n    private async Task<string> GetToken()\n    {\n        // Note: This is a placeholder - implement based on your actual token service\n        // Using the same pattern as your original code\n        var httpClient = new HttpClient();\n        \n        // Implementation would depend on your specific token service\n        return \"placeholder-token\";\n    }\n}\n// --- Main Processor Class ---\npublic class GetConfirmLOPProcessor\n{\n    private readonly AuthService _authService;\n    private readonly ConfirmLOPService _confirmLOPService;\n    public GetConfirmLOPProcessor()\n    {\n        _authService = new AuthService();\n        _confirmLOPService = new ConfirmLOPService(_authService);\n    }\n    // --- Main Script Function ---\n    public async Task<IDictionary<string, object>> mainFunction(string userName, string startDate, string endDate, string authorizationHeader)\n    {\n        try\n        {\n            if (string.IsNullOrEmpty(userName))\n            {\n                return new Dictionary<string, object> {\n                    { \"statusCode\", 400 },\n                    { \"body\", new { message = \"Invalid UserName\" } }\n                };\n            }\n            if (string.IsNullOrEmpty(startDate))\n            {\n                return new Dictionary<string, object> {\n                    { \"statusCode\", 400 },\n                    { \"body\", new { message = \"Invalid startDate\" } }\n                };\n            }\n            if (string.IsNullOrEmpty(endDate))\n            {\n                return new Dictionary<string, object> {\n                    { \"statusCode\", 400 },\n                    { \"body\", new { message = \"Invalid endDate\" } }\n                };\n            }\n            if (string.IsNullOrEmpty(authorizationHeader) || !authorizationHeader.StartsWith(\"Bearer \", StringComparison.OrdinalIgnoreCase))\n            {\n                return new Dictionary<string, object> {\n                    { \"statusCode\", 401 },\n                    { \"body\", new { message = \"Unauthorized. Access token is missing or invalid.\" } }\n                };\n            }\n            if (!_authService.IsUserEqualsToTokenUser(userName, authorizationHeader))\n            {\n                return new Dictionary<string, object> {\n                    { \"statusCode\", 401 },\n                    { \"body\", new { message = \"Unauthorized. Access Denied for Requested User.\" } }\n                };\n            }\n            return await _confirmLOPService.GetEmployeeConfirmLOPData(userName, startDate, endDate, authorizationHeader);\n        }\n        catch (JsonException e)\n        {\n            return new Dictionary<string, object> {\n                { \"statusCode\", 400 },\n                { \"body\", new { message = \"Invalid inputs\" } }\n            };\n        }\n        catch (Exception e)\n        {\n            return new Dictionary<string, object> {\n                { \"statusCode\", 500 },\n                { \"body\", new { message = \"Internal server error\" } }\n            };\n        }\n    }\n}\n// --- Script Execution ---\n// Example usage\nstring userName = \"testuser\";\nstring startDate = \"2024-01-01\";\nstring endDate = \"2024-01-31\";\nstring authorizationHeader = \"Bearer your-token-here\";\nvar processor = new GetConfirmLOPProcessor();\nvar resultObject = await processor.mainFunction(userName, startDate, endDate, authorizationHeader);\n// Output the result\nresultObject",
				"isAsync":false
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute CSharp script",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":916,
				"resourceName":"callables_return_response_to_api",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_otcPG-1",
			"id":"n_nXgwV",
			"index":3,
			"inputs":{
				"streamingCompleted":true,
				"responseName":"200_undefined",
				"status":200
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to API request",
			"type":"STOP"
		}
	],
	"ownerUserId":39714,
	"projectId":1927,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":false,
	"tags":[
		
	],
	"version":6
}