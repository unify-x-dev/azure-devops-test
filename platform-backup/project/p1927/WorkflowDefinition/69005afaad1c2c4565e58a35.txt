{
	"appsUsed":[
		
	],
	"createdTime":1761630970243,
	"deleted":false,
	"edges":[
		{
			"fromNodeId":"n_w6Fgz",
			"priority":0,
			"skip":false,
			"toNodeId":"n_51Fju",
			"type":"next"
		},
		{
			"fromNodeId":"n_51Fju",
			"priority":0,
			"skip":false,
			"toNodeId":"n_2Wbzq",
			"type":"next"
		},
		{
			"fromNodeId":"n_2Wbzq",
			"name":"yes",
			"priority":0,
			"skip":false,
			"toNodeId":"n_qxJV3",
			"type":"if"
		},
		{
			"fromNodeId":"n_qxJV3",
			"priority":0,
			"skip":false,
			"toNodeId":"n_TtIeq",
			"type":"next"
		},
		{
			"fromNodeId":"n_2Wbzq",
			"name":"no",
			"priority":0,
			"skip":false,
			"toNodeId":"n_TtIeq",
			"type":"next"
		}
	],
	"id":"69005afaad1c2c4565e58a35",
	"lastModifiedBy":39715,
	"lcName":"removenonprocessmessages",
	"modifiedTime":1761640807645,
	"name":"RemoveNonProcessMessages",
	"nodes":[
		{
			"context":{
				"appName":"callables",
				"resourceVersion":1154,
				"resourceName":"callables_from_api"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_fXaki-1",
			"id":"n_w6Fgz",
			"index":1,
			"inputs":{
				"request":{
					"contentType":"application/json"
				},
				"endpointType":"REST",
				"response":[
					{
						"name":"ok",
						"status":200,
						"contentType":"application/json",
						"textBody":{
							"type":"string"
						}
					},
					{
						"status":500,
						"contentType":"application/json",
						"textBody":{
							"type":"string"
						}
					}
				],
				"streamingResponse":false
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Trigger via API",
			"trigger":{
				"type":"CALLABLE"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":223,
				"resourceName":"code_by_unifyapps_csharp",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_fXaki-1",
			"id":"n_51Fju",
			"index":2,
			"inputs":{
				"output":{
					"type":"object",
					"additionalProperties":false,
					"required":[
						"responseState"
					],
					"properties":{
						"responseState":{
							"type":"boolean",
							"title":"Response State"
						}
					}
				},
				"code":"using System;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json;\nusing System.Net.Http;\nusing System.Collections.Generic;\nusing Microsoft.Azure.ServiceBus.Management;\n\n\nclass ManagementClientConstants\n{\n    public const int QueueNameMaximumLength = 260;\n    public const int TopicNameMaximumLength = 260;\n    public const int SubscriptionNameMaximumLength = 50;\n    public const int RuleNameMaximumLength = 50;\n    public const string AtomNamespace = \"http://www.w3.org/2005/Atom\";\n    public const string ServiceBusNamespace = \"http://schemas.microsoft.com/netservices/2010/10/servicebus/connect\";\n    public const string XmlSchemaInstanceNamespace = \"http://www.w3.org/2001/XMLSchema-instance\";\n    public const string XmlSchemaNamespace = \"http://www.w3.org/2001/XMLSchema\";\n    public const string SerializationNamespace = \"http://schemas.microsoft.com/2003/10/Serialization/\";\n    public const string AtomContentType = \"application/atom+xml\";\n    public const string apiVersionQuery = \"api-version=\" + ApiVersion;\n    public const string ApiVersion = \"2017-04\";\n    public const string ServiceBusSupplementartyAuthorizationHeaderName = \"ServiceBusSupplementaryAuthorization\";\n    public const string ServiceBusDlqSupplementaryAuthorizationHeaderName = \"ServiceBusDlqSupplementaryAuthorization\";\n    public const string HttpErrorSubCodeFormatString = \"SubCode={0}\";\n    public static string ConflictOperationInProgressSubCode =\n        string.Format(HttpErrorSubCodeFormatString, ExceptionErrorCodes.ConflictOperationInProgress.ToString(\"D\"));\n    public static string ForbiddenInvalidOperationSubCode =\n        string.Format(HttpErrorSubCodeFormatString, ExceptionErrorCodes.ForbiddenInvalidOperation.ToString(\"D\"));\n    public static readonly TimeSpan MinimumAllowedTimeToLive = TimeSpan.FromSeconds(1);\n    public static readonly TimeSpan MaximumAllowedTimeToLive = TimeSpan.MaxValue;\n    public static readonly TimeSpan MinimumLockDuration = TimeSpan.FromSeconds(5);\n    public static readonly TimeSpan MaximumLockDuration = TimeSpan.FromMinutes(5);\n    public static readonly TimeSpan MinimumAllowedAutoDeleteOnIdle = TimeSpan.FromMinutes(5);\n    public static readonly TimeSpan MaximumDuplicateDetectionHistoryTimeWindow = TimeSpan.FromDays(7);\n    public static readonly TimeSpan MinimumDuplicateDetectionHistoryTimeWindow = TimeSpan.FromSeconds(20);\n    public static readonly int MinAllowedMaxDeliveryCount = 1;\n    public static readonly int MaxUserMetadataLength = 1024;\n    public static char[] InvalidEntityPathCharacters = { '@', '?', '#', '*' };\n    // Authorization constants\n    public static readonly int SupportedClaimsCount = 3;\n    /// <summary>Specifies the error codes of the exceptions.</summary>\n    public enum ExceptionErrorCodes\n    {\n        /// <summary>A parse error encountered while processing a request.</summary>\n        BadRequest = 40000,\n        /// <summary>A generic unauthorized error.</summary>\n        UnauthorizedGeneric = 40100,\n        /// <summary>The service bus has no transport security.</summary>\n        NoTransportSecurity = 40101,\n        /// <summary>The token is missing.</summary>\n        MissingToken = 40102,\n        /// <summary>The signature is invalid.</summary>\n        InvalidSignature = 40103,\n        /// <summary>The audience is invalid.</summary>\n        InvalidAudience = 40104,\n        /// <summary>A malformed token.</summary>\n        MalformedToken = 40105,\n        /// <summary>The token had expired.</summary>\n        ExpiredToken = 40106,\n        /// <summary>The audience is not found.</summary>\n        AudienceNotFound = 40107,\n        /// <summary>The expiry date not found.</summary>\n        ExpiresOnNotFound = 40108,\n        /// <summary>The issuer cannot be found.</summary>\n        IssuerNotFound = 40109,\n        /// <summary>The signature cannot be found.</summary>\n        SignatureNotFound = 40110,\n        /// <summary>The incoming ip has been rejected by policy.</summary>\n        IpRejected = 40111,\n        /// <summary>The incoming ip is not in acled subnet.</summary>\n        IpNotInAcledSubNet = 40112,\n        /// <summary>A generic forbidden error.</summary>\n        ForbiddenGeneric = 40300,\n        /// <summary>Operation is not allowed.</summary>\n        ForbiddenInvalidOperation = 40301,\n        /// <summary>The endpoint is not found.</summary>\n        EndpointNotFound = 40400,\n        /// <summary>The destination is invalid.</summary>\n        InvalidDestination = 40401,\n        /// <summary>The namespace is not found.</summary>\n        NamespaceNotFound = 40402,\n        /// <summary>The store lock is lost.</summary>\n        StoreLockLost = 40500,\n        /// <summary>The SQL filters exceeded its allowable maximum number.</summary>\n        SqlFiltersExceeded = 40501,\n        /// <summary>The correlation filters exceeded its allowable maximum number.</summary>\n        CorrelationFiltersExceeded = 40502,\n        /// <summary>The subscriptions exceeded its allowable maximum number.</summary>\n        SubscriptionsExceeded = 40503,\n        /// <summary>A conflict during updating occurred.</summary>\n        UpdateConflict = 40504,\n        /// <summary>The Event Hub is at full capacity.</summary>\n        EventHubAtFullCapacity = 40505,\n        /// <summary>A generic conflict error.</summary>\n        ConflictGeneric = 40900,\n        /// <summary>An operation is in progress.</summary>\n        ConflictOperationInProgress = 40901,\n        /// <summary>The entity is not found.</summary>\n        EntityGone = 41000,\n        /// <summary>An internal error that is not specified.</summary>\n        UnspecifiedInternalError = 50000,\n        /// <summary>The error of data communication.</summary>\n        DataCommunicationError = 50001,\n        /// <summary>An internal error.</summary>\n        InternalFailure = 50002,\n        /// <summary>The provider is unreachable.</summary>\n        ProviderUnreachable = 50003,\n        /// <summary>The server is busy.</summary>\n        ServerBusy = 50004,\n        /// <summary> Archive Storage Account Server is busy. </summary>\n        ArchiveStorageAccountServerBusy = 50005,\n        /// <summary> Archive Storage Account ResourceId is invalid. </summary>\n        InvalidArchiveStorageAccountResourceId = 50006,\n        /// <summary>The error is caused by bad gateway.</summary>\n        BadGatewayFailure = 50200,\n        /// <summary>The gateway did not receive a timely response from the upstream server.</summary>\n        GatewayTimeoutFailure = 50400,\n        /// <summary>This exception detail will be used for those exceptions that are thrown without specific any explicit exception detail.</summary>\n        UnknownExceptionDetail = 60000,\n    }\n}\n\n\npublic class QueueDescription : IEquatable<QueueDescription>\n    {\n        internal TimeSpan duplicateDetectionHistoryTimeWindow = TimeSpan.FromMinutes(1);\n        internal string path;\n        internal bool? internalSupportOrdering = null;\n        TimeSpan lockDuration = TimeSpan.FromSeconds(60);\n        TimeSpan defaultMessageTimeToLive = TimeSpan.MaxValue;\n        TimeSpan autoDeleteOnIdle = TimeSpan.MaxValue;\n        int maxDeliveryCount = 10;\n        string forwardTo = null;\n        string forwardDeadLetteredMessagesTo = null;\n        string userMetadata = null;\n\n        /// <summary>\n        /// Initializes a new instance of QueueDescription class with the specified relative path.\n        /// </summary>\n        /// <param name=\"path\">Path of the queue relative to the namespace base address.</param>\n        public QueueDescription(string path)\n        {\n            this.Path = path;\n        }\n\n        /// <summary>\n        /// Path of the queue relative to the namespace base address.\n        /// </summary>\n        /// <remarks>Max length is 260 chars. Cannot start or end with a slash.\n        /// Cannot have restricted characters: '@','?','#','*'</remarks>\n        public string Path\n        {\n            get => this.path;\n            set\n            {\n                EntityNameHelper.CheckValidQueueName(value, nameof(Path));\n                this.path = value;\n            }\n        }\n\n        /// <summary>\n        /// Duration of a peek lock receive. i.e., the amount of time that the message is locked by a given receiver so that\n        /// no other receiver receives the same message.\n        /// </summary>\n        /// <remarks>Max value is 5 minutes. Default value is 60 seconds.</remarks>\n        public TimeSpan LockDuration\n        {\n            get => this.lockDuration;\n            set\n            {\n                TimeoutHelper.ThrowIfNonPositiveArgument(value, nameof(LockDuration));\n                this.lockDuration = value;\n            }\n        }\n\n        /// <summary>\n        /// The maximum size of the queue in megabytes, which is the size of memory allocated for the queue.\n        /// </summary>\n        /// <remarks>Default value is 1024.</remarks>\n        public long MaxSizeInMB { get; set; } = 1024;\n\n        /// <summary>\n        /// This value indicates if the queue requires guard against duplicate messages. If true, duplicate messages having same\n        /// <see cref=\"Message.MessageId\"/> and sent to queue within duration of <see cref=\"DuplicateDetectionHistoryTimeWindow\"/>\n        /// will be discarded.\n        /// </summary>\n        /// <remarks>Defaults to false.</remarks>\n        public bool RequiresDuplicateDetection { get; set; } = false;\n\n        /// <summary>\n        /// This indicates whether the queue supports the concept of session. Sessionful-messages follow FIFO ordering.\n        /// </summary>\n        /// <remarks>\n        /// If true, the receiver can only receive messages using <see cref=\"SessionClient.AcceptMessageSessionAsync()\"/>.\n        /// Defaults to false.\n        /// </remarks>\n        public bool RequiresSession { get; set; } = false;\n\n        /// <summary>\n        /// The default time to live value for the messages. This is the duration after which the message expires, starting from when\n        /// the message is sent to Service Bus. </summary>\n        /// <remarks>\n        /// This is the default value used when <see cref=\"Message.TimeToLive\"/> is not set on a\n        ///  message itself. Messages older than their TimeToLive value will expire and no longer be retained in the message store.\n        ///  Subscribers will be unable to receive expired messages.\n        ///  Default value is <see cref=\"TimeSpan.MaxValue\"/>.\n        ///  </remarks>\n        public TimeSpan DefaultMessageTimeToLive\n        {\n            get => this.defaultMessageTimeToLive;\n            set\n            {\n                if (value < ManagementClientConstants.MinimumAllowedTimeToLive || value > ManagementClientConstants.MaximumAllowedTimeToLive)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(DefaultMessageTimeToLive),\n                        $\"The value must be between {ManagementClientConstants.MinimumAllowedTimeToLive} and {ManagementClientConstants.MaximumAllowedTimeToLive}\");\n                }\n\n                this.defaultMessageTimeToLive = value;\n            }\n        }\n\n        /// <summary>\n        /// The <see cref=\"TimeSpan\"/> idle interval after which the queue is automatically deleted.\n        /// </summary>\n        /// <remarks>The minimum duration is 5 minutes. Default value is <see cref=\"TimeSpan.MaxValue\"/>.</remarks>\n        public TimeSpan AutoDeleteOnIdle\n        {\n            get => this.autoDeleteOnIdle;\n            set\n            {\n                if (value < ManagementClientConstants.MinimumAllowedAutoDeleteOnIdle)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(AutoDeleteOnIdle),\n                        $\"The value must be greater than {ManagementClientConstants.MinimumAllowedAutoDeleteOnIdle}\");\n                }\n\n                this.autoDeleteOnIdle = value;\n            }\n        }\n\n        /// <summary>\n        /// Indicates whether this queue has dead letter support when a message expires.\n        /// </summary>\n        /// <remarks>If true, the expired messages are moved to dead-letter sub-queue. Default value is false.</remarks>\n        public bool EnableDeadLetteringOnMessageExpiration { get; set; } = false;\n\n        /// <summary>\n        /// The <see cref=\"TimeSpan\"/> duration of duplicate detection history that is maintained by the service.\n        /// </summary>\n        /// <remarks>\n        /// The default value is 1 minute. Max value is 7 days and minimum is 20 seconds.\n        /// </remarks>\n        public TimeSpan DuplicateDetectionHistoryTimeWindow\n        {\n            get => this.duplicateDetectionHistoryTimeWindow;\n            set\n            {\n                if (value < ManagementClientConstants.MinimumDuplicateDetectionHistoryTimeWindow || value > ManagementClientConstants.MaximumDuplicateDetectionHistoryTimeWindow)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(DuplicateDetectionHistoryTimeWindow),\n                        $\"The value must be between {ManagementClientConstants.MinimumDuplicateDetectionHistoryTimeWindow} and {ManagementClientConstants.MaximumDuplicateDetectionHistoryTimeWindow}\");\n                }\n\n                this.duplicateDetectionHistoryTimeWindow = value;\n            }\n        }\n\n        /// <summary>\n        /// The maximum delivery count of a message before it is dead-lettered.\n        /// </summary>\n        /// <remarks>The delivery count is increased when a message is received in <see cref=\"ReceiveMode.PeekLock\"/> mode\n        /// and didn't complete the message before the message lock expired.\n        /// Default value is 10. Minimum value is 1.</remarks>\n        public int MaxDeliveryCount\n        {\n            get => this.maxDeliveryCount;\n            set\n            {\n                if (value < ManagementClientConstants.MinAllowedMaxDeliveryCount)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(MaxDeliveryCount),\n                        $\"The value must be greater than {ManagementClientConstants.MinAllowedMaxDeliveryCount}\");\n                }\n\n                this.maxDeliveryCount = value;\n            }\n        }\n\n        /// <summary>\n        /// Indicates whether server-side batched operations are enabled.\n        /// </summary>\n        /// <remarks>Defaults to true.</remarks>\n        public bool EnableBatchedOperations { get; set; } = true;\n\n        /// <summary>\n        /// The <see cref=\"AuthorizationRules\"/> on the queue to control user access at entity level.\n        /// </summary>\n        public AuthorizationRules AuthorizationRules { get; internal set; } = new AuthorizationRules();\n\n        /// <summary>\n        /// The current status of the queue (Enabled / Disabled).\n        /// </summary>\n        /// <remarks>When an entity is disabled, that entity cannot send or receive messages.</remarks>\n        public EntityStatus Status { get; set; } = EntityStatus.Active;\n\n        /// <summary>\n        /// The path of the recipient entity to which all the messages sent to the queue are forwarded to.\n        /// </summary>\n        /// <remarks>If set, user cannot manually receive messages from this queue. The destination entity\n        /// must be an already existing entity.</remarks>\n        public string ForwardTo\n        {\n            get => this.forwardTo;\n            set\n            {\n                if (string.IsNullOrWhiteSpace(value))\n                {\n                    this.forwardTo = value;\n                    return;\n                }\n\n                EntityNameHelper.CheckValidQueueName(value, nameof(ForwardTo));\n                if (this.path.Equals(value, StringComparison.CurrentCultureIgnoreCase))\n                {\n                    throw new InvalidOperationException(\"Entity cannot have auto-forwarding policy to itself\");\n                }\n\n                this.forwardTo = value;\n            }\n        }\n\n        /// <summary>\n        /// The path of the recipient entity to which all the dead-lettered messages of this queue are forwarded to.\n        /// </summary>\n        /// <remarks>If set, user cannot manually receive dead-lettered messages from this queue. The destination\n        /// entity must already exist.</remarks>\n        public string ForwardDeadLetteredMessagesTo\n        {\n            get => this.forwardDeadLetteredMessagesTo;\n            set\n            {\n                if (string.IsNullOrWhiteSpace(value))\n                {\n                    this.forwardDeadLetteredMessagesTo = value;\n                    return;\n                }\n\n                EntityNameHelper.CheckValidQueueName(value, nameof(ForwardDeadLetteredMessagesTo));\n                if (this.path.Equals(value, StringComparison.CurrentCultureIgnoreCase))\n                {\n                    throw new InvalidOperationException(\"Entity cannot have auto-forwarding policy to itself\");\n                }\n\n                this.forwardDeadLetteredMessagesTo = value;\n            }\n        }\n\n        /// <summary>\n        /// Indicates whether the queue is to be partitioned across multiple message brokers.\n        /// </summary>\n        /// <remarks>Defaults to false.</remarks>\n        public bool EnablePartitioning { get; set; } = false;\n\n        /// <summary>\n        /// Custom metdata that user can associate with the description.\n        /// </summary>\n        /// <remarks>Cannot be null. Max length is 1024 chars.</remarks>\n        public string UserMetadata\n        {\n            get => this.userMetadata;\n            set\n            {\n                if (value == null)\n                {\n                    throw new ArgumentNullException(nameof(UserMetadata), $\"Value cannot be null\");\n                }\n\n                if (value.Length > ManagementClientConstants.MaxUserMetadataLength)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(UserMetadata), $\"Length cannot cross {ManagementClientConstants.MaxUserMetadataLength} characters\");\n                }\n\n                this.userMetadata = value;\n            }\n        }\n\n        internal bool IsAnonymousAccessible { get; set; } = false;\n\n        internal bool SupportOrdering\n        { \n            get\n            {\n                return this.internalSupportOrdering ?? !this.EnablePartitioning;\n            }\n            set\n            {\n                this.internalSupportOrdering = value;\n            }\n        }\n\n        internal bool EnableExpress { get; set; } = false;\n\n        /// <summary>\n        /// List of properties that were retrieved using GetQueue but are not understood by this version of client is stored here.\n        /// The list will be sent back when an already retrieved QueueDescription will be used in UpdateQueue call.\n        /// </summary>\n        internal List<XElement> UnknownProperties { get; set; }\n\n        public override int GetHashCode()\n        {\n            return this.Path?.GetHashCode() ?? base.GetHashCode();\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as QueueDescription;\n            return this.Equals(other);\n        }\n\n        public bool Equals(QueueDescription otherDescription)\n        {\n            if (otherDescription is QueueDescription other\n                && this.Path.Equals(other.Path, StringComparison.OrdinalIgnoreCase)\n                && this.AutoDeleteOnIdle.Equals(other.AutoDeleteOnIdle)\n                && this.DefaultMessageTimeToLive.Equals(other.DefaultMessageTimeToLive)\n                && (!this.RequiresDuplicateDetection || this.DuplicateDetectionHistoryTimeWindow.Equals(other.DuplicateDetectionHistoryTimeWindow))\n                && this.EnableBatchedOperations == other.EnableBatchedOperations\n                && this.EnableDeadLetteringOnMessageExpiration == other.EnableDeadLetteringOnMessageExpiration\n                && this.EnablePartitioning == other.EnablePartitioning\n                && string.Equals(this.ForwardDeadLetteredMessagesTo, other.ForwardDeadLetteredMessagesTo, StringComparison.OrdinalIgnoreCase)\n                && string.Equals(this.ForwardTo, other.ForwardTo, StringComparison.OrdinalIgnoreCase)\n                && this.LockDuration.Equals(other.LockDuration)\n                && this.MaxDeliveryCount == other.MaxDeliveryCount\n                && this.MaxSizeInMB == other.MaxSizeInMB\n                && this.RequiresDuplicateDetection.Equals(other.RequiresDuplicateDetection)\n                && this.RequiresSession.Equals(other.RequiresSession)\n                && this.Status.Equals(other.Status)\n                && this.SupportOrdering.Equals(other.SupportOrdering)\n                && this.EnableExpress == other.EnableExpress\n                && this.IsAnonymousAccessible == other.IsAnonymousAccessible\n                && string.Equals(this.userMetadata, other.userMetadata, StringComparison.OrdinalIgnoreCase)\n                && (this.AuthorizationRules != null && other.AuthorizationRules != null\n                    || this.AuthorizationRules == null && other.AuthorizationRules == null)\n                && (this.AuthorizationRules == null || this.AuthorizationRules.Equals(other.AuthorizationRules)))\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        public static bool operator ==(QueueDescription o1, QueueDescription o2)\n        {\n            if (ReferenceEquals(o1, o2))\n            {\n                return true;\n            }\n\n            if (ReferenceEquals(o1, null) || ReferenceEquals(o2, null))\n            {\n                return false;\n            }\n\n            return o1.Equals(o2);\n        }\n\n        public static bool operator !=(QueueDescription o1, QueueDescription o2)\n        {\n            return !(o1 == o2);\n        }\n    }\n\n    /// <summary>\n    /// Represents the metadata description of the topic.\n    /// </summary>\npublic class TopicDescription : IEquatable<TopicDescription>\n{\n    internal TimeSpan duplicateDetectionHistoryTimeWindow = TimeSpan.FromMinutes(1);\n    internal string path;\n    TimeSpan defaultMessageTimeToLive = TimeSpan.MaxValue;\n    TimeSpan autoDeleteOnIdle = TimeSpan.MaxValue;\n    string userMetadata = null;\n    /// <summary>\n    /// Initializes a new instance of TopicDescription class with the specified relative path.\n    /// </summary>\n    /// <param name=\"path\">Path of the topic relative to the namespace base address.</param>\n    public TopicDescription(string path)\n    {\n        this.Path = path;\n    }\n    /// <summary>\n    /// The default time to live value for the messages. This is the duration after which the message expires, starting from when\n    /// the message is sent to Service Bus. </summary>\n    /// <remarks>\n    /// This is the default value used when <see cref=\"Message.TimeToLive\"/> is not set on a\n    ///  message itself. Messages older than their TimeToLive value will expire and no longer be retained in the message store.\n    ///  Subscribers will be unable to receive expired messages.\n    ///  Default value is <see cref=\"TimeSpan.MaxValue\"/>.\n    ///  </remarks>\n    public TimeSpan DefaultMessageTimeToLive\n    {\n        get => this.defaultMessageTimeToLive;\n        set\n        {\n            if (value < ManagementClientConstants.MinimumAllowedTimeToLive || value > ManagementClientConstants.MaximumAllowedTimeToLive)\n            {\n                throw new ArgumentOutOfRangeException(nameof(DefaultMessageTimeToLive),\n                    $\"The value must be between {ManagementClientConstants.MinimumAllowedTimeToLive} and {ManagementClientConstants.MaximumAllowedTimeToLive}\");\n            }\n            this.defaultMessageTimeToLive = value;\n        }\n    }\n    /// <summary>\n    /// The <see cref=\"TimeSpan\"/> idle interval after which the topic is automatically deleted.\n    /// </summary>\n    /// <remarks>The minimum duration is 5 minutes. Default value is <see cref=\"TimeSpan.MaxValue\"/>.</remarks>\n    public TimeSpan AutoDeleteOnIdle\n    {\n        get => this.autoDeleteOnIdle;\n        set\n        {\n            if (value < ManagementClientConstants.MinimumAllowedAutoDeleteOnIdle)\n            {\n                throw new ArgumentOutOfRangeException(nameof(AutoDeleteOnIdle),\n                    $\"The value must be greater than {ManagementClientConstants.MinimumAllowedAutoDeleteOnIdle}\");\n            }\n            this.autoDeleteOnIdle = value;\n        }\n    }\n    /// <summary>\n    /// The maximum size of the topic in megabytes, which is the size of memory allocated for the topic.\n    /// </summary>\n    /// <remarks>Default value is 1024.</remarks>\n    public long MaxSizeInMB { get; set; } = 1024;\n    /// <summary>\n    /// This value indicates if the topic requires guard against duplicate messages. If true, duplicate messages having same\n    /// <see cref=\"Message.MessageId\"/> and sent to topic within duration of <see cref=\"DuplicateDetectionHistoryTimeWindow\"/>\n    /// will be discarded.\n    /// </summary>\n    /// <remarks>Defaults to false.</remarks>\n    public bool RequiresDuplicateDetection { get; set; } = false;\n    /// <summary>\n    /// The <see cref=\"TimeSpan\"/> duration of duplicate detection history that is maintained by the service.\n    /// </summary>\n    /// <remarks>\n    /// The default value is 1 minute. Max value is 7 days and minimum is 20 seconds.\n    /// </remarks>\n    public TimeSpan DuplicateDetectionHistoryTimeWindow\n    {\n        get => this.duplicateDetectionHistoryTimeWindow;\n        set\n        {\n            if (value < ManagementClientConstants.MinimumDuplicateDetectionHistoryTimeWindow || value > ManagementClientConstants.MaximumDuplicateDetectionHistoryTimeWindow)\n            {\n                throw new ArgumentOutOfRangeException(nameof(DuplicateDetectionHistoryTimeWindow),\n                    $\"The value must be between {ManagementClientConstants.MinimumDuplicateDetectionHistoryTimeWindow} and {ManagementClientConstants.MaximumDuplicateDetectionHistoryTimeWindow}\");\n            }\n            this.duplicateDetectionHistoryTimeWindow = value;\n        }\n    }\n    /// <summary>\n    /// Path of the topic relative to the namespace base address.\n    /// </summary>\n    /// <remarks>Max length is 260 chars. Cannot start or end with a slash.\n    /// Cannot have restricted characters: '@','?','#','*'</remarks>\n    public string Path\n    {\n        get => this.path;\n        set\n        {\n            EntityNameHelper.CheckValidTopicName(value, nameof(Path));\n            this.path = value;\n        }\n    }\n    /// <summary>\n    /// The <see cref=\"AuthorizationRules\"/> on the topic to control user access at entity level.\n    /// </summary>\n    public AuthorizationRules AuthorizationRules { get; internal set; } = new AuthorizationRules();\n    /// <summary>\n    /// The current status of the topic (Enabled / Disabled).\n    /// </summary>\n    /// <remarks>When an entity is disabled, that entity cannot send or receive messages.</remarks>\n    public EntityStatus Status { get; set; } = EntityStatus.Active;\n    /// <summary>\n    /// Indicates whether the topic is to be partitioned across multiple message brokers.\n    /// </summary>\n    /// <remarks>Defaults to false.</remarks>\n    public bool EnablePartitioning { get; set; } = false;\n    /// <summary>\n    /// Defines whether ordering needs to be maintained. If true, messages sent to topic will be\n    /// forwarded to the subscription in order.\n    /// </summary>\n    /// <remarks>Defaults to false.</remarks>\n    public bool SupportOrdering { get; set; } = false;\n    /// <summary>\n    /// Indicates whether server-side batched operations are enabled.\n    /// </summary>\n    /// <remarks>Defaults to true.</remarks>\n    public bool EnableBatchedOperations { get; set; } = true;\n    /// <summary>\n    /// Custom metdata that user can associate with the description.\n    /// </summary>\n    /// <remarks>Cannot be null. Max length is 1024 chars.</remarks>\n    public string UserMetadata\n    {\n        get => this.userMetadata;\n        set\n        {\n            if (value == null)\n            {\n                throw new ArgumentNullException(nameof(UserMetadata), $\"Value cannot be null\");\n            }\n            if (value.Length > ManagementClientConstants.MaxUserMetadataLength)\n            {\n                throw new ArgumentOutOfRangeException(nameof(UserMetadata), $\"Length cannot cross {ManagementClientConstants.MaxUserMetadataLength} characters\");\n            }\n            this.userMetadata = value;\n        }\n    }\n    internal bool IsAnonymousAccessible { get; set; } = false;\n    internal bool FilteringMessagesBeforePublishing { get; set; } = false;\n    internal string ForwardTo { get; set; } = null;\n    internal bool EnableExpress { get; set; } = false;\n    internal bool EnableSubscriptionPartitioning { get; set; } = false;\n    /// <summary>\n    /// List of properties that were retrieved using GetTopic but are not understood by this version of client is stored here.\n    /// The list will be sent back when an already retrieved TopicDescription will be used in UpdateTopic call.\n    /// </summary>\n    internal List<object> UnknownProperties { get; set; }\n    public override int GetHashCode()\n    {\n        return this.Path?.GetHashCode() ?? base.GetHashCode();\n    }\n    public override bool Equals(object obj)\n    {\n        var other = obj as TopicDescription;\n        return this.Equals(other);\n    }\n    public bool Equals(TopicDescription otherDescription)\n    {\n        if (otherDescription is TopicDescription other\n            && this.Path.Equals(other.Path, StringComparison.OrdinalIgnoreCase)\n            && this.AutoDeleteOnIdle.Equals(other.AutoDeleteOnIdle)\n            && this.DefaultMessageTimeToLive.Equals(other.DefaultMessageTimeToLive)\n            && (!this.RequiresDuplicateDetection || this.DuplicateDetectionHistoryTimeWindow.Equals(other.DuplicateDetectionHistoryTimeWindow))\n            && this.EnableBatchedOperations == other.EnableBatchedOperations\n            && this.EnablePartitioning == other.EnablePartitioning\n            && this.MaxSizeInMB == other.MaxSizeInMB\n            && this.RequiresDuplicateDetection.Equals(other.RequiresDuplicateDetection)\n            && this.Status.Equals(other.Status)\n            && string.Equals(this.userMetadata, other.userMetadata, StringComparison.OrdinalIgnoreCase)\n            && string.Equals(this.ForwardTo, other.ForwardTo, StringComparison.OrdinalIgnoreCase)\n            && this.EnableExpress == other.EnableExpress\n            && this.IsAnonymousAccessible == other.IsAnonymousAccessible\n            && this.FilteringMessagesBeforePublishing == other.FilteringMessagesBeforePublishing\n            && this.EnableSubscriptionPartitioning == other.EnableSubscriptionPartitioning\n            && (this.AuthorizationRules != null && other.AuthorizationRules != null\n                || this.AuthorizationRules == null && other.AuthorizationRules == null)\n            && (this.AuthorizationRules == null || this.AuthorizationRules.Equals(other.AuthorizationRules)))\n        {\n            return true;\n        }\n        return false;\n    }\n    public static bool operator ==(TopicDescription o1, TopicDescription o2)\n    {\n        if (ReferenceEquals(o1, o2))\n        {\n            return true;\n        }\n        if (ReferenceEquals(o1, null) || ReferenceEquals(o2, null))\n        {\n            return false;\n        }\n        return o1.Equals(o2);\n    }\n    public static bool operator !=(TopicDescription o1, TopicDescription o2)\n    {\n        return !(o1 == o2);\n    }\n}\n\n\npublic static class EntityNameHelper\n    {\n        private const string PathDelimiter = @\"/\";\n        private const string SubscriptionsSubPath = \"Subscriptions\";\n        private const string RulesSubPath = \"Rules\";\n        private const string SubQueuePrefix = \"$\";\n        private const string DeadLetterQueueSuffix = \"DeadLetterQueue\";\n        private const string DeadLetterQueueName = SubQueuePrefix + DeadLetterQueueSuffix;\n        private const string Transfer = \"Transfer\";\n        private const string TransferDeadLetterQueueName = SubQueuePrefix + Transfer + PathDelimiter + DeadLetterQueueName;\n\n        /// <summary>\n        /// Formats the dead letter path for either a queue, or a subscription.\n        /// </summary>\n        /// <param name=\"entityPath\">The name of the queue, or path of the subscription.</param>\n        /// <returns>The path as a string of the dead letter entity.</returns>\n        public static string FormatDeadLetterPath(string entityPath)\n        {\n            return EntityNameHelper.FormatSubQueuePath(entityPath, EntityNameHelper.DeadLetterQueueName);\n        }\n\n        /// <summary>\n        /// Formats the subqueue path for either a queue, or a subscription.\n        /// </summary>\n        /// <param name=\"entityPath\">The name of the queue, or path of the subscription.</param>\n        /// <returns>The path as a string of the subqueue entity.</returns>\n        public static string FormatSubQueuePath(string entityPath, string subQueueName)\n        {\n            return string.Concat(entityPath, EntityNameHelper.PathDelimiter, subQueueName);\n        }\n\n        /// <summary>\n        /// Formats the subscription path, based on the topic path and subscription name.\n        /// </summary>\n        /// <param name=\"topicPath\">The name of the topic, including slashes.</param>\n        /// <param name=\"subscriptionName\">The name of the subscription.</param>\n        public static string FormatSubscriptionPath(string topicPath, string subscriptionName)\n        {\n            return string.Concat(topicPath, PathDelimiter, SubscriptionsSubPath, PathDelimiter, subscriptionName);\n        }\n\n        /// <summary>\n        /// Formats the rule path, based on the topic path, subscription name and rule name.\n        /// </summary>\n        /// <param name=\"topicPath\">The name of the topic, including slashes.</param>\n        /// <param name=\"subscriptionName\">The name of the subscription.</param>\n        /// <param name=\"ruleName\">The name of the rule</param>\n        public static string FormatRulePath(string topicPath, string subscriptionName, string ruleName)\n        {\n            return string.Concat(\n                topicPath, PathDelimiter, \n                SubscriptionsSubPath, PathDelimiter, \n                subscriptionName, PathDelimiter, \n                RulesSubPath, PathDelimiter, ruleName);\n        }\n\n        /// <summary>\n        /// Utility method that creates the name for the transfer dead letter receiver, specified by <paramref name=\"entityPath\"/>\n        /// </summary>\n        public static string Format​Transfer​Dead​Letter​Path(string entityPath)\n        {\n            return string.Concat(entityPath, PathDelimiter, TransferDeadLetterQueueName);\n        }\n\n        internal static void CheckValidQueueName(string queueName, string paramName = \"queuePath\")\n        {\n            CheckValidEntityName(GetPathWithoutBaseUri(queueName), ManagementClientConstants.QueueNameMaximumLength, true, paramName);\n        }\n\n        internal static void CheckValidTopicName(string topicName, string paramName = \"topicPath\")\n        {\n            CheckValidEntityName(topicName, ManagementClientConstants.TopicNameMaximumLength, true, paramName);\n        }\n\n        internal static void CheckValidSubscriptionName(string subscriptionName, string paramName = \"subscriptionName\")\n        {\n            CheckValidEntityName(subscriptionName, ManagementClientConstants.SubscriptionNameMaximumLength, false, paramName);\n        }\n\n        internal static void CheckValidRuleName(string ruleName, string paramName = \"ruleName\")\n        {\n            CheckValidEntityName(ruleName, ManagementClientConstants.RuleNameMaximumLength, false, paramName);\n        }\n\n        private static void CheckValidEntityName(string entityName, int maxEntityNameLength, bool allowSeparator, string paramName)\n        {\n            if (string.IsNullOrWhiteSpace(entityName))\n            {\n                throw new ArgumentNullException(paramName);\n            }\n\n            // and \"\\\" will be converted to \"/\" on the REST path anyway. Gateway/REST do not\n            // have to worry about the begin/end slash problem, so this is purely a client side check.\n            var tmpName = entityName.Replace(@\"\\\", Constants.PathDelimiter);\n            if (tmpName.Length > maxEntityNameLength)\n            {\n                throw new ArgumentOutOfRangeException(paramName, $@\"Entity path '{entityName}' exceeds the '{maxEntityNameLength}' character limit.\");\n            }\n\n            if (tmpName.StartsWith(Constants.PathDelimiter, StringComparison.OrdinalIgnoreCase) ||\n                tmpName.EndsWith(Constants.PathDelimiter, StringComparison.OrdinalIgnoreCase))\n            {\n                throw new ArgumentException($@\"The entity name/path cannot contain '/' as prefix or suffix. The supplied value is '{entityName}'\", paramName);\n            }\n\n            if (!allowSeparator && tmpName.Contains(Constants.PathDelimiter))\n            {\n                throw new ArgumentException($@\"The entity name/path contains an invalid character '{Constants.PathDelimiter}'\", paramName);\n            }\n\n            foreach (var uriSchemeKey in ManagementClientConstants.InvalidEntityPathCharacters)\n            {\n                if (entityName.IndexOf(uriSchemeKey) >= 0)\n                {\n                    throw new ArgumentException($@\"'{entityName}' contains character '{uriSchemeKey}' which is not allowed because it is reserved in the Uri scheme.\", paramName);\n                }\n            }\n        }\n\n        private static string GetPathWithoutBaseUri(string entityName)\n        {\n            // Note: on Linux/macOS, \"/path\" URLs are treated as valid absolute file URLs.\n            // To ensure relative queue paths are correctly rejected on these platforms,\n            // an additional check using IsWellFormedOriginalString() is made here.\n            // See https://github.com/dotnet/corefx/issues/22098 for more information.\n            if (Uri.TryCreate(entityName, UriKind.Absolute, out Uri uriValue) &&\n                uriValue.IsWellFormedOriginalString())\n            {\n                entityName = uriValue.PathAndQuery;\n                return entityName.TrimStart('/');\n            }\n            return entityName;\n        }\n    }\n\npublic  String GetRequestResultAsync(String secretName)\n{\n    log.LogInformation(\"Call to get Service Request Result :\" + secretName);\n    String keyVaultUrl = Environment.GetEnvironmentVariable(\"keyVaultUrl\");\n    //String keyVaultUrl = \"https://virtu-keyvaultfn-dev3.azurewebsites.net/api/keyvault/virtuEAGIntegKV-dev3/secrets?code=vjohKWp6zVu4k8ZwQ/CGIaOXStBnoqqg9f3/KsStnNJmrLyMB4wkPw==\";\n    keyVaultUrl = keyVaultUrl + \"&items=\" + secretName;\n//    log.LogInformation(\"Key vault url\" + keyVaultUrl);\n   \n    String result = GetResponseAsync(secretName, keyVaultUrl).GetAwaiter().GetResult();\n    // log.LogInformation(\"got response\" + result);\n    return result;\n}\n\npublic string getServiceBusConnetion()\n{\n    //return SERVICEBUSCONNECTION;\n    // log.LogInformation(\"Getting ServiceBusConnection String from the KeyvaultFunction\");\n      \n   String serviceBusConnection = GetRequestResultAsync(\"ServiceBusConnectionString\");\n    return serviceBusConnection;\n}\n\npublic string CreateQueryStringToGetNonProcessingMessages()\n{\n    String queryString = \"select Top 500 SequnceNum, DeadletterReason, ErrorDescription, dlqMessage, Reprocess, subscriberID, TopicName, inserttime from messagegraveyard where Reprocess = 'NO'\"\n    return queryString;\n}\n\npublic async Task<String> GetResponseAsync(String secretName,string path)\n{\n    HttpClient client = new HttpClient();\n  \n   \n    HttpResponseMessage response = await client.GetAsync(path);\n    String s = response.Content.ReadAsStringAsync().GetAwaiter().GetResult();\n    //String[] array = JSONDecoders.DecodeJsStringArray(s);\n    // log.LogInformation(\"RESPONSE \" + s);\n    JsonObject[] obj = (JsonObject[])Newtonsoft.Json.JsonConvert.DeserializeObject<JsonObject[]>(s);\n    JsonObject value = Array.Find(obj, element => element.name == secretName);\n    // log.LogInformation(\" Result Vaule from the keyvault\" + value.value);\n    if (response.IsSuccessStatusCode)\n    {\n        // log.LogInformation(\"Secreat is received succssfully\");\n        return value.value;\n    }\n    // log.LogError(\" ERROR on getting requested secret value\");\n    return null;\n}\n\n\npublic bool RemoveNonProcessMessages(String connectionString, List<object[]> objects)\n        {\n\n            // get the processing messages from the GraveYardTable\n\n            // DatabaseOperations dbOps = new DatabaseOperations();\n            // SqlConnection conn = dbOps.OpenConncetion(log);\n            // String queryString = dbOps.CreateQueryStringToGetNonProcessingMessages();\n            // LinkedList<Object[]> resultsList = dbOps.ReadDb(queryString, 8, log);\n            TopicOperations topicOps = new TopicOperations();\n          //  MessagingFactory messagingFactory = MessagingFactory.CreateFromConnectionString(connectionString);\n            ServiceBusClient serviceBusClient = new ServiceBusClient(connectionString);\n            // var messageReceiver = messagingFactory.CreateMessageReceiver(SubscriptionClient.FormatSubscriptionPath(topicName, subscriberID + \"/$DeadLetterQueue\"));\n\n            // iterate the trough the messag list \n            foreach (Object[] obj in resultsList)\n            {\n                String subscriberID = obj[5].ToString();\n                String topicName = obj[6].ToString();\n                long seqNum = long.Parse(obj[0].ToString());\n\n                var messageReceiver = serviceBusClient.CreateReceiver(topicName, subscriberID + \"/$DeadLetterQueue\");\n                bool requeMessageStatus = topicOps.RemoveMessageFromDLQ(messageReceiver, seqNum, subscriberID, log);\n\n                if (requeMessageStatus)\n                {\n\n\n                    //update Reprocess status\n                    dbOps.UpdateReProcessStatus(\"REM\", conn, subscriberID, topicName, seqNum.ToString(), log);\n                    // insert data to archive table\n                    dbOps.InsertMessageDetailsToGraveYardArchiveTable(conn, seqNum.ToString(), subscriberID, topicName, log);\n                    // remove from the graveyard\n                    dbOps.removeRecordFromGraveYard(conn, subscriberID, topicName, seqNum.ToString(), log);\n\n\n                    log.LogInformation(\"Message removed from the DLQ  \" + seqNum);\n                }\n                else\n                {\n                    log.LogInformation(\"Errorr update the database \" + seqNum);\n                }\n\n                // release Resources\n                messageReceiver.CloseAsync().GetAwaiter().GetResult();\n\n            }\n\n            serviceBusClient.DisposeAsync().GetAwaiter().GetResult();\n            conn.Close();\n\n            return true;\n        }\n\n\n",
				"isAsync":false,
				"parameters":{
					"topic":"{{ n_w6Fgz.outputs.queryParams.topic }}",
					"subscription":""
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute CSharp script",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"if_else",
				"resourceVersion":791,
				"resourceName":"if_else_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_fXaki-1",
			"id":"n_2Wbzq",
			"index":3,
			"inputs":{},
			"skip":false,
			"subTitle":"Condition",
			"title":"Condition",
			"type":"IF_ELSE"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":1124,
				"resourceName":"callables_return_response_to_api",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"n_2Wbzq@_fXaki-1@y",
			"id":"n_qxJV3",
			"index":4,
			"inputs":{
				"streamingCompleted":true,
				"responseName":"200_ok",
				"status":200
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to API request",
			"type":"STOP"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":1123,
				"resourceName":"callables_return_response_to_api",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_fXaki-1",
			"id":"n_TtIeq",
			"index":5,
			"inputs":{
				"streamingCompleted":true,
				"responseName":"500_undefined",
				"status":500
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to API request",
			"type":"STOP"
		}
	],
	"ownerUserId":39715,
	"projectId":1927,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":false,
	"tags":[
		
	],
	"version":6
}