{
	"appsUsed":[
		
	],
	"createdTime":1761722476207,
	"deleted":false,
	"edges":[
		{
			"fromNodeId":"n_XhbEi",
			"priority":0,
			"skip":false,
			"toNodeId":"n_8rSjZ",
			"type":"next"
		},
		{
			"fromNodeId":"n_8rSjZ",
			"priority":0,
			"skip":false,
			"toNodeId":"n_jH3B7",
			"type":"next"
		}
	],
	"id":"6901c06c118bae6f22702777",
	"lastModifiedBy":45518,
	"lcName":"[azure-function]updatecheckinapproval (copy)",
	"modifiedTime":1761827502202,
	"name":"[Azure-function]UpdateCheckInApproval (copy)",
	"nodes":[
		{
			"context":{
				"appName":"callables",
				"resourceVersion":1155,
				"resourceName":"callables_from_api"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_Vznjc-1",
			"id":"n_XhbEi",
			"index":1,
			"inputs":{
				"request":{
					"contentType":"application/json"
				},
				"endpointType":"REST",
				"response":[
					{
						"status":200,
						"contentType":"application/json",
						"textBody":{
							"type":"string"
						}
					}
				],
				"streamingResponse":false
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Trigger via API",
			"trigger":{
				"type":"CALLABLE"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":224,
				"resourceName":"code_by_unifyapps_csharp",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_Vznjc-1",
			"id":"n_8rSjZ",
			"index":2,
			"inputs":{
				"code":"using System;\nusing System.Threading.Tasks;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.Json;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Microsoft.Extensions.Logging;\n\n// --- Base Models ---\n\npublic class CheckInApprovalList\n{\n    public List<CheckInApproval> items { get; set; } = new List<CheckInApproval>();\n}\n\npublic class CheckInApproval\n{\n    public string id { get; set; }\n    public string gteEmployeeNo { get; set; }\n    public int year { get; set; }\n    public int week { get; set; }\n    public string gteProjectId { get; set; }\n    public string projectName { get; set; }\n    public string name { get; set; }\n    public string teamMembersGteEmployeeNo { get; set; }\n    public decimal time { get; set; }\n    public string app { get; set; }\n    public string subCategory { get; set; }\n    public string status { get; set; }\n}\n\npublic class CheckInApprovalData\n{\n    public string gteEmployeeNo { get; set; }\n    public int year { get; set; }\n    public int week { get; set; }\n    public List<ApprovalData> approvalData { get; set; } = new List<ApprovalData>();\n}\n\npublic class ApprovalData\n{\n    public string gteProjectId { get; set; }\n    public string projectName { get; set; }\n    public List<TeamMembers> teamMembers { get; set; } = new List<TeamMembers>();\n}\n\npublic class TeamMembers\n{\n    public string gteEmployeeNo { get; set; }\n    public string name { get; set; }\n    public decimal time { get; set; }\n}\n\n// --- Logic Classes ---\n\npublic class CheckInApprovalProcessor\n{\n    private static readonly HttpClient checkinGetClient = new HttpClient();\n    private static readonly HttpClient checkinPatchClient = new HttpClient();\n    private const string CheckInApiBaseUrl = \"https://api.checkin-system.com/api\";\n\n    private static readonly JsonSerializerOptions jsonOptions = new JsonSerializerOptions\n    {\n        PropertyNameCaseInsensitive = true,\n        PropertyNamingPolicy = JsonNamingPolicy.CamelCase\n    };\n\n    // Logger instance\n    private ILogger _log;\n\n    // --- CheckIn API Methods ---\n\n    public async Task<CheckInApprovalList> GetCheckInTimeApprovalsAsync(string email, string token)\n    {\n        _log?.LogInformation(\"Starting time approvals from CheckIn for email: {Email}\", email);\n\n        var approvalList = new CheckInApprovalList();\n        checkinGetClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(\"Bearer\", token);\n\n        DateTime now = DateTime.Now;\n        DateTime startDate = now.AddDays(-90);\n        DateTime endDate = now.AddDays(30);\n        Calendar cal = new CultureInfo(\"en-US\").Calendar;\n\n        try\n        {\n            while (startDate <= endDate)\n            {\n                var requestUrl = $\"{CheckInApiBaseUrl}/approval?user-name={email}&year={startDate.Year}&week-no={cal.GetWeekOfYear(startDate, CalendarWeekRule.FirstFullWeek, DayOfWeek.Monday)}\";\n\n                var getUserRequest = new HttpRequestMessage(HttpMethod.Get, requestUrl);\n                getUserRequest.Content = new StringContent(\"\", Encoding.ASCII, \"application/json\");\n\n                startDate = startDate.AddDays(7);\n\n                var response = await checkinGetClient.SendAsync(getUserRequest);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    var errorContent = await response.Content.ReadAsStringAsync();\n                    _log?.LogWarning(\"CheckIn API returned non-success status: {StatusCode}, Content: {Content}\", response.StatusCode, errorContent);\n\n                    if (response.StatusCode == System.Net.HttpStatusCode.NotFound &&\n                        (errorContent.Contains(\"No Pending Approvals\") ||\n                         errorContent.Contains(\"No Data Found\") ||\n                         errorContent.Contains(\"Value not found!\")))\n                    {\n                        continue;\n                    }\n                }\n\n                var responseContent = await response.Content.ReadAsStringAsync();\n                var approvalData = JsonSerializer.Deserialize<CheckInApprovalData>(responseContent, jsonOptions);\n\n                if (approvalData != null)\n                {\n                    approvalList.items.AddRange(MapToApprovalList(approvalData));\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            _log?.LogError(ex, \"Error getting CheckIn time approvals\");\n            throw;\n        }\n\n        _log?.LogInformation(\"Completed getting time approvals from CheckIn for email: {Email}\", email);\n        return approvalList;\n    }\n\n    public async Task PatchCheckInTimeApprovalAsync(CheckInApprovalList approvalList, string token)\n    {\n        _log?.LogInformation(\"Starting to send time approvals to CheckIn\");\n\n        var approveList = approvalList.items?.Where(s => s.status?.ToLower() == \"approve\").ToList() ?? new List<CheckInApproval>();\n        var rejectList = approvalList.items?.Where(s => s.status?.ToLower() == \"reject\").ToList() ?? new List<CheckInApproval>();\n\n        var newApproveList = GroupApprovalData(approveList);\n        var newRejectList = GroupApprovalData(rejectList);\n\n        checkinPatchClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(\"Bearer\", token);\n\n        try\n        {\n            await ProcessApprovalBatch(newApproveList, \"A\");\n            await ProcessApprovalBatch(newRejectList, \"R\");\n        }\n        catch (Exception ex)\n        {\n            _log?.LogError(ex, \"Error sending approvals to CheckIn\");\n            throw;\n        }\n\n        _log?.LogInformation(\"Completed sending time approvals to CheckIn\");\n    }\n\n    private IEnumerable<CheckInApprovalData> GroupApprovalData(List<CheckInApproval> approvals)\n    {\n        return approvals\n            .GroupBy(x => new { x.year, x.week, x.gteEmployeeNo })\n            .Select(group => new CheckInApprovalData\n            {\n                year = group.Key.year,\n                week = group.Key.week,\n                gteEmployeeNo = group.Key.gteEmployeeNo,\n                approvalData = group\n                    .GroupBy(a => new { a.gteProjectId })\n                    .Select(projectGroup => new ApprovalData\n                    {\n                        gteProjectId = projectGroup.Key.gteProjectId,\n                        teamMembers = projectGroup\n                            .GroupBy(b => new { b.teamMembersGteEmployeeNo })\n                            .Select(employeeGroup => new TeamMembers\n                            {\n                                gteEmployeeNo = employeeGroup.Key.teamMembersGteEmployeeNo\n                            }).ToList()\n                    }).ToList()\n            });\n    }\n\n    private async Task ProcessApprovalBatch(IEnumerable<CheckInApprovalData> approvalBatch, string action)\n    {\n        foreach (var approvalData in approvalBatch)\n        {\n            var payload = new\n            {\n                gteEmployeeNo = approvalData.gteEmployeeNo,\n                approvalData = approvalData.approvalData.Select(a => new\n                {\n                    gteProjectId = a.gteProjectId,\n                    teamMembers = a.teamMembers.Select(t => t.gteEmployeeNo).ToList()\n                }).ToList()\n            };\n\n            var jsonPayload = JsonSerializer.Serialize(payload, jsonOptions);\n            var requestUrl = $\"{CheckInApiBaseUrl}/approval/{approvalData.year}/{approvalData.week}/{action}\";\n\n            var request = new HttpRequestMessage(HttpMethod.Put, requestUrl);\n            request.Content = new StringContent(jsonPayload, Encoding.UTF8, \"application/json\");\n\n            var response = await checkinPatchClient.SendAsync(request);\n\n            if (!response.IsSuccessStatusCode)\n            {\n                var errorContent = await response.Content.ReadAsStringAsync();\n                _log?.LogError(\"CheckIn PATCH API returned non-success status: {StatusCode}, Content: {Content}\", response.StatusCode, errorContent);\n            }\n\n            response.EnsureSuccessStatusCode();\n        }\n    }\n\n    private List<CheckInApproval> MapToApprovalList(CheckInApprovalData checkinApprovalData)\n    {\n        var approvalList = new List<CheckInApproval>();\n\n        foreach (var approvalData in checkinApprovalData.approvalData)\n        {\n            foreach (var teamMember in approvalData.teamMembers)\n            {\n                try\n                {\n                    var checkInApproval = new CheckInApproval\n                    {\n                        id = $\"{approvalData.gteProjectId}{checkinApprovalData.year}{checkinApprovalData.week}\",\n                        gteEmployeeNo = checkinApprovalData.gteEmployeeNo,\n                        year = checkinApprovalData.year,\n                        week = checkinApprovalData.week,\n                        gteProjectId = approvalData.gteProjectId,\n                        projectName = approvalData.projectName,\n                        name = teamMember.name,\n                        teamMembersGteEmployeeNo = teamMember.gteEmployeeNo,\n                        time = teamMember.time,\n                        app = \"CheckIn\",\n                        subCategory = \"Time Approval\"\n                    };\n\n                    approvalList.Add(checkInApproval);\n                }\n                catch (Exception ex)\n                {\n                    _log?.LogError(ex, \"Error mapping approval data\");\n                }\n            }\n        }\n\n        return approvalList;\n    }\n\n    // --- Main Script Function ---\n    public async Task<IDictionary<string, object>> mainFunction(string requestBody, string email, string authorizationHeader)\n    {\n        try\n        {\n            // Validate email format\n            if (!IsValidEmail(email))\n            {\n                return new Dictionary<string, object> {\n                    { \"statusCode\", 400 },\n                    { \"body\", new { message = \"Invalid email format provided\" } }\n                };\n            }\n\n            // Validate authorization header\n            if (string.IsNullOrEmpty(authorizationHeader))\n            {\n                return new Dictionary<string, object> {\n                    { \"statusCode\", 400 },\n                    { \"body\", new { message = \"Authorization header is required\" } }\n                };\n            }\n\n            var token = authorizationHeader.Split(' ').LastOrDefault();\n            if (string.IsNullOrEmpty(token))\n            {\n                return new Dictionary<string, object> {\n                    { \"statusCode\", 400 },\n                    { \"body\", new { message = \"Invalid authorization token format\" } }\n                };\n            }\n\n            // Parse request body\n            var approvalList = JsonSerializer.Deserialize<CheckInApprovalList>(requestBody, jsonOptions);\n            if (approvalList?.items == null || !approvalList.items.Any())\n            {\n                return new Dictionary<string, object> {\n                    { \"statusCode\", 400 },\n                    { \"body\", new { message = \"Invalid approval data in request body\" } }\n                };\n            }\n\n            // Process approvals\n            await PatchCheckInTimeApprovalAsync(approvalList, token);\n\n            _log?.LogInformation(\"Successfully updated CheckIn approvals for email: {Email}\", email);\n\n            return new Dictionary<string, object> {\n                { \"statusCode\", 200 },\n                { \"body\", new {\n                    message = \"CheckIn approvals updated successfully\",\n                    processedCount = approvalList.items.Count,\n                    email = email\n                }}\n            };\n        }\n        catch (System.Net.Http.HttpRequestException ex)\n        {\n            _log?.LogError(ex, \"HTTP request error during CheckIn approval update\");\n            return new Dictionary<string, object> {\n                { \"statusCode\", 502 },\n                { \"body\", new { message = \"CheckIn service unavailable\" } }\n            };\n        }\n        catch (JsonException ex)\n        {\n            _log?.LogError(ex, \"JSON parsing error during CheckIn approval update\");\n            return new Dictionary<string, object> {\n                { \"statusCode\", 400 },\n                { \"body\", new { message = \"Invalid JSON in request body\" } }\n            };\n        }\n        catch (Exception ex)\n        {\n            _log?.LogError(ex, \"Unexpected error during CheckIn approval update\");\n            return new Dictionary<string, object> {\n                { \"statusCode\", 500 },\n                { \"body\", new { message = \"Internal server error during approval update\" } }\n            };\n        }\n    }\n\n    private bool IsValidEmail(string email)\n    {\n        return Regex.IsMatch(email,\n            @\"^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$\",\n            RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(250));\n    }\n\n    // Additional method to get approvals\n    public async Task<IDictionary<string, object>> GetApprovalsFunction(string email, string authorizationHeader, ILogger log = null)\n    {\n        this._log = log;\n\n        try\n        {\n            _log?.LogInformation(\"Getting CheckIn approvals for email: {Email}\", email);\n\n            if (!IsValidEmail(email))\n            {\n                return new Dictionary<string, object> {\n                    { \"statusCode\", 400 },\n                    { \"body\", new { message = \"Invalid email format provided\" } }\n                };\n            }\n\n            var token = authorizationHeader?.Split(' ').LastOrDefault();\n            if (string.IsNullOrEmpty(token))\n            {\n                return new Dictionary<string, object> {\n                    { \"statusCode\", 400 },\n                    { \"body\", new { message = \"Invalid authorization token\" } }\n                };\n            }\n\n            var approvals = await GetCheckInTimeApprovalsAsync(email, token);\n\n            return new Dictionary<string, object> {\n                { \"statusCode\", 200 },\n                { \"body\", new {\n                    message = \"CheckIn approvals retrieved successfully\",\n                    approvals = approvals,\n                    count = approvals.items.Count\n                }}\n            };\n        }\n        catch (Exception ex)\n        {\n            _log?.LogError(ex, \"Error getting CheckIn approvals\");\n            return new Dictionary<string, object> {\n                { \"statusCode\", 500 },\n                { \"body\", new { message = \"Error retrieving approvals\" } }\n            };\n        }\n    }\n}\n\n// --- Script Execution ---\n\n// Example usage for updating approvals\nstring requestBody = @\"{\n    \"\"items\"\": [\n        {\n            \"\"id\"\": \"\"PROJ001202415\"\",\n            \"\"gteEmployeeNo\"\": \"\"EMP001\"\",\n            \"\"year\"\": 2024,\n            \"\"week\"\": 15,\n            \"\"gteProjectId\"\": \"\"PROJ001\"\",\n            \"\"projectName\"\": \"\"Project One\"\",\n            \"\"name\"\": \"\"John Doe\"\",\n            \"\"teamMembersGteEmployeeNo\"\": \"\"EMP002\"\",\n            \"\"time\"\": 40.0,\n            \"\"app\"\": \"\"CheckIn\"\",\n            \"\"subCategory\"\": \"\"Time Approval\"\",\n            \"\"status\"\": \"\"approve\"\"\n        }\n    ]\n}\";\n\nstring email = \"user@company.com\";\nstring authorizationHeader = \"Bearer your-token-here\";\n\nvar processor = new CheckInApprovalProcessor();\nvar resultObject = await processor.mainFunction(requestBody, email, authorizationHeader);\n\n// Output the result\nresultObject",
				"isAsync":false
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute CSharp script",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":1124,
				"resourceName":"callables_return_response_to_api",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_Vznjc-1",
			"id":"n_jH3B7",
			"index":3,
			"inputs":{
				"streamingCompleted":true,
				"responseName":"200_undefined",
				"status":200
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to API request",
			"type":"STOP"
		}
	],
	"ownerUserId":45518,
	"projectId":1927,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":false,
	"tags":[
		
	],
	"version":1
}